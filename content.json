{"meta":{"title":"webwlsong","subtitle":"无","description":"webwlsong的博客","author":"webwlsong","url":"https://webwlsong.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2020-09-09T11:15:36.129Z","updated":"2020-09-09T11:15:36.129Z","comments":false,"path":"/404.html","permalink":"https://webwlsong.github.io//404.html","excerpt":"","text":""},{"title":"关于","date":"2020-09-09T11:15:36.137Z","updated":"2020-09-09T11:15:36.137Z","comments":false,"path":"about/index.html","permalink":"https://webwlsong.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"书单","date":"2020-09-09T11:15:36.137Z","updated":"2020-09-09T11:15:36.137Z","comments":false,"path":"books/index.html","permalink":"https://webwlsong.github.io/books/index.html","excerpt":"","text":"douban 豆瓣书单 douban: user: webwlsong # 豆瓣用户名 start: 0 # 从哪一条记录开始 count: 100 # 获取豆瓣书单数据条"},{"title":"分类","date":"2020-09-09T11:15:36.137Z","updated":"2020-09-09T11:15:36.137Z","comments":false,"path":"categories/index.html","permalink":"https://webwlsong.github.io/categories/index.html","excerpt":"","text":"Github github: username: webwlsong # github username"},{"title":"友情链接","date":"2020-09-09T11:15:36.137Z","updated":"2020-09-09T11:15:36.137Z","comments":true,"path":"links/index.html","permalink":"https://webwlsong.github.io/links/index.html","excerpt":"","text":"Name: link: http://example.com avatar: http://example.com/avatar.png desc: “这是一个描述”"},{"title":"Repositories","date":"2020-09-09T11:15:36.137Z","updated":"2020-09-09T11:15:36.137Z","comments":false,"path":"repository/index.html","permalink":"https://webwlsong.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-09-09T11:15:36.137Z","updated":"2020-09-09T11:15:36.137Z","comments":false,"path":"tags/index.html","permalink":"https://webwlsong.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"test","slug":"2020/2020-09/2020-09-09","date":"+020202-09-08T16:00:00.000Z","updated":"2020-09-09T11:15:36.133Z","comments":true,"path":"20202/09/08/2020/2020-09/2020-09-09/","link":"","permalink":"https://webwlsong.github.io/20202/09/08/2020/2020-09/2020-09-09/","excerpt":"","text":"2222 test","categories":[{"name":"test","slug":"test","permalink":"https://webwlsong.github.io/categories/test/"}],"tags":[{"name":"test","slug":"test","permalink":"https://webwlsong.github.io/tags/test/"}]},{"title":"Mac用串口(ttl)连接树莓派3b+以及串口调试","slug":"2020/2020-09/2020-09-07","date":"+020202-09-06T16:00:00.000Z","updated":"2020-09-09T11:15:36.133Z","comments":true,"path":"20202/09/06/2020/2020-09/2020-09-07/","link":"","permalink":"https://webwlsong.github.io/20202/09/06/2020/2020-09/2020-09-07/","excerpt":"","text":"MacOSX用串口(TTL)连接树莓派 树莓派在没有显示使用时，可以使用usb串口转ttl进行连接。 USB转ttl线 CP2102下载对应的驱动 USB转TTL 驱动下载地址：http://pan.baidu.com/s/1mgCFd9m 安装完成后重启系统，插入 USB to TTL 线可查询串口设备。 12$ ls /dev/tty.usbserial* #在Mac是这个，去查看。插拔usb能够看到对应的设备/dev/tty.usbserial USB转TTL线 树莓派3b+引脚图 USB to TTL 线与树莓派针脚对应关系为： GND -&gt; GND RXD -&gt; GPIO 14(TXD) TXD -&gt; GPIO 15(RXD) VCC -&gt; 悬空 (切记, 不要乱接) 注意: 一定按照上面的对应关系，不要接成一样的。 配置minicom参数 运行 1sudo minicom -s 进入minicom界面 123456789101112┌─────[configuration]──────┐│ Filenames and paths ││ File transfer protocols ││ Serial port setup ││ Modem and dialing ││ Screen and keyboard ││ Save setup as dfl ││ Save setup as.. ││ Exit ││ Exit from Minicom │└──────────────────────────┘ 使用上下键选择Serial port setup，回车。此时停留在change which setting? 通过A,B,C,D选项设置对应的参数设置例如下 123456789101112┌───────────────────────────────────────────────────────────────────────┐│ A - Serial Device : /dev/modem ││ B - Lockfile Location : /usr/local/Cellar/minicom/2.7.1/var ││ C - Callin Program : ││ D - Callout Program : ││ E - Bps/Par/Bits : 115200 8N1 ││ F - Hardware Flow Control : Yes ││ G - Software Flow Control : No ││ ││ Change which setting? │└───────────────────────────────────────────────────────────────────────┘ 配置选项目录 选择&quot;Filenames and paths&quot; 1234567891011┌───────────────────────────────────────────────────────────────────────┐│ A - Download directory : /home/wonux ││ B - Upload directory : /tmp ││ C - Script directory : /root/minicom ││ D - Script program : runscript or /bin/bash ││ E - Kermit program : ││ F - Logging options ││ ││ Change which setting? │└───────────────────────────────────────────────────────────────────────┘ 常用配置总结： 选择Serial port setup 配置选项如下： 1234A - Serial Device : /dev/modem E - Bps/Par/Bits : 115200 8N1 F - Hardware Flow Control : No G - Software Flow Control : No 选择Filenames and paths 配置其中的如下配置项： 12C - Script directory : /root/minicomD - Script program : /bin/bash C:脚本文件的存放位置: g运行脚本时的路径 。 D:选择脚本程序: 默认runscript,也可以选择bash脚本格式。 树莓派3b+添加散热外壳 在某宝上买了一个外壳。 线与树莓派针脚对应关系为： 红色-&gt; +5v 黑色-&gt; GND #地线 mac串口调试工具minicom 我们使用常用的串口工具，如：minicom, screen 使用 115200 进行连接。它们的安装也非常的方便： 123456789# 安装 minicom$ brew install minicom# 进行配置后再进行连接$ minicom -s# 安装 screen$ brew install screen# 进行连接screen /dev/tty.usbserial 115200 连接后我们输入默认的账号和密码 12用户名：pi密码：raspberry 树莓派连接上网设置 12345678910111213141516171819202122ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdevupdate_config=1country=GBnetwork=&#123; ssid=\"######\" #wifi 名称 psk=\"*******\" #wifi密码 proto=RSN key_mgmt=WPA-PSK #加密方式 pairwise=CCMP auth_alg=OPEN&#125;network=&#123; ssid=\"#######\" psk=\"**********\" proto=RSN key_mgmt=WPA-PSK pairwise=CCMP auth_alg=OPEN&#125;~ 完整呈现： 参考资料： https://blog.csdn.net/sikinzen/article/details/5451758 minicom中文手册 https://www.jianshu.com/p/71191dd41eab https://www.jianshu.com/p/40412eb7f567 https://www.jianshu.com/p/b132508a0fa3?from=singlemessage","categories":[],"tags":[{"name":"树莓派","slug":"树莓派","permalink":"https://webwlsong.github.io/tags/树莓派/"}]},{"title":"图解Golang的内存管理分配","slug":"2020/2020-09/2020-09-02","date":"2020-09-02T16:00:00.000Z","updated":"2020-09-09T11:15:36.133Z","comments":true,"path":"2020/09/02/2020/2020-09/2020-09-02/","link":"","permalink":"https://webwlsong.github.io/2020/09/02/2020/2020-09/2020-09-02/","excerpt":"","text":"go主要有以下五种内存存储区(c/c++也是一样)： Go的内存分配核心思想 Go是内置运行时的编程语言(runtime)，像这种内置运行时的编程语言通常会抛弃传统的内存分配方式，改为自己管理。这样可以完成类似预分配、内存池等操作，以避开系统调用带来的性能问题，防止每次分配内存都需要系统调用。 用户线程的调度以及生命周期管理都是用户层面，Go语言自己实现的，不借助OS系统调用，减少系统资源消耗。 Go的内存分配的核心思想可以分为以下几点： 每次从操作系统申请一大块儿的内存，由Go来对这块儿内存做分配，减少系统调用 内存分配算法采用Google的TCMalloc算法。算法比较复杂，究其原理可自行查阅。其核心思想就是把内存切分的非常的细小，分为多级管理，以降低锁的粒度。 回收对象内存时，并没有将其真正释放掉，只是放回预先分配的大块内存中，以便复用。只有内存闲置过多的时候，才会尝试归还部分内存给操作系统，降低整体开销 业界比较出名的内存分配器有Google的tcmalloc和Facebook的jemalloc。二者在避免内存碎片和性能上均比glic有比较大的优势，在多线程环境中效果更明显。 程序在内存中的分布 代码段(.text)，也称文本段(Text Segment)，存放着程序的机器码和只读数据，可执行指令就是从这里取得的。如果可能，系统会安排好相同程序的多个运行实体共享这些实例代码。这个段在内存中一般被标记为只读，任何对该区的写操作都会导致段错误（Segmentation Fault） 数据段，包括已初始化的数据段(.data)和未初始化的数据段（.bss），前者用来存放保存全局的和静态的已初始化变量，后者用来保存全局的和静态的未初始化变量。数据段在编译时分配 堆栈段分为堆和栈： 堆（Heap）：用来存储程序运行时分配的变量。堆的大小并不固定，可动态扩张或缩减。其分配由malloc()、new()等这类实时内存分配函数来实现。当进程调用malloc等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用free 等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减） 堆的内存释放由应用程序去控制，通常一个new()就要对应一个delete()，如果程序员没有释放掉，那么在程序结束后操作系统会自动回收。 栈（Stack）是一种用来存储函数调用时的临时信息的结构，如函数调用所传递的参数、函数的返回地址、函数的局部变量等。 在程序运行时由编译器在需要的时候分配，在不需要的时候自动清除。 栈的特性: 最后一个放入栈中的物体总是被最先拿出来，这个特性通常称为先进后出(FILO)队列。` 栈的基本操作： PUSH操作：向栈中添加数据，称为压栈，数据将放置在栈顶； POP操作：POP操作相反，在栈顶部移去一个元素，并将栈的大小减一，称为弹栈。 堆和栈的区别 分配和管理方式不同 ： 堆是动态分配的，其空间的分配和释放都由程序员控制。 栈由编译器自动管理。栈有两种分配方式：静态分配和动态分配。 静态分配由编译器完成，比如局部变量的分配。 动态分配由alloca()函数进行分配，但是栈的动态分配和堆是不同的，它的动态分配是由编译器进行释放，无须手工控制。 产生碎片不同 对堆来说，频繁的new/delete或者malloc/free势必会造成内存空间的不连续，造成大量的碎片，使程序效率降低。 对栈而言，则不存在碎片问题，因为栈是先进后出的队列，永远不可能有一个内存块从栈中间弹出。 生长方向不同 堆是向着内存地址增加的方向增长的，从内存的低地址向高地址方向增长。 栈的生长方向与之相反，是向着内存地址减小的方向增长，由内存的高地址向低地址方向增长。 了解更多： 图解TCMalloc goole内存分配器 C/C++程序的5种内存存储区及示意 参考文献: 程序在内存中的分布 https://www.cnblogs.com/Lynn-Zhang/p/5449199.html 从内存分配开始 https://mp.weixin.qq.com/s/EyWKFRu1xryoHY386QUcuA 译文：Go 内存分配器可视化指南 https://www.linuxzen.com/go-memory-allocator-visual-guide.html 图解Go语言内存分配 https://juejin.im/post/5c888a79e51d456ed11955a8 Golang源码探索(三) GC的实现原理 https://www.cnblogs.com/zkweb/p/7880099.html 《Go专家编程》Go 内存管理 https://my.oschina.net/renhc/blog/2236782?spm=a2c4e.10696291.0.0.a8e219a4hLvsZx 雨痕&lt;&lt;Go源码解析&gt;&gt; go内存分配(英文) https://andrestc.com/post/go-memory-allocation-pt1/","categories":[],"tags":[{"name":"go","slug":"go","permalink":"https://webwlsong.github.io/tags/go/"},{"name":"c","slug":"c","permalink":"https://webwlsong.github.io/tags/c/"},{"name":"c++","slug":"c","permalink":"https://webwlsong.github.io/tags/c/"},{"name":"内存","slug":"内存","permalink":"https://webwlsong.github.io/tags/内存/"},{"name":"堆栈","slug":"堆栈","permalink":"https://webwlsong.github.io/tags/堆栈/"}]},{"title":"DIY服务器搭建，内网穿透搭建","slug":"2020/2020-08/2020-08-31","date":"2020-08-31T09:09:00.000Z","updated":"2020-09-09T11:15:36.129Z","comments":true,"path":"2020/08/31/2020/2020-08/2020-08-31/","link":"","permalink":"https://webwlsong.github.io/2020/08/31/2020/2020-08/2020-08-31/","excerpt":"","text":"起初一直在用云服务器来搭自用服务器，为什么还要用自建一个服务器？ 云服务价格偏高性 性能达不到要求 IT人爱折腾，生命不止，学习不止 服务器选择 耗电量小 性价比高 噪声小(几乎没有噪声) 考虑过台式工作站服务器，NAS，最终选择mini电脑当自用服务器。 制作U盘Linux启动盘 推荐使用工具rufus(推荐),UltraISO(不太推荐) rufus做好启动盘之后，不需要修改卷标 UltraIOS启动盘 U盘启动电脑进入安装界面 12vmlinuz initrd=initrd.img inst.stage2=hd:LABEL=CentOS\\x207\\x20x86_64 rd.live.check quiet #这是按 Tab 键后的默认值； rufus 启动 通常ubuntu桌面和显卡驱动不兼容，导致安装完整之后进入不到桌面 解决方法： 1:更换桌面管理器 2:进入tty 按ctrl+alt+f2 12sudo apt install lightdmsudo service lightdm restart 默认启动多用户启动 12sudo systemctl set-default multi-user.target#然后输入reboot命令重启： 单次启动图形界面: 12sudo systemctl start graphical.targetswitchdesk GNOME&quot;,回车，再输入&quot;startx 默认启动为图形界面: 12systemctl set-default graphical.target#然后执行reboot命令重启系统即可。 设置无线上网，Ubuntu20.04.1是这个目录 12345678910vim /etc/netplan/01-network-manager-all.yaml#添加 ethernets: wlp1s0: #配置的网卡的名称 dhcp4: no #关闭DHCP，如果需要打开DHCP则写yes dhcp6: no addresses: [192.168.1.10/24] #配置的静态ip地址和掩码 gateway4: 192.168.1.1 #网关地址 nameservers: addresses: [192.168.1.1,114.114.114.114] #DNS服务器地址，多个DNS服务器地址需要用英文逗号分隔开 使其ip生效 1sudo netplan apply 现在查看一下 IP是否生效 1ip addr 或者 ifconfig frp内网穿透 设备清单： 一台云主机 一台家用服务器 frp 官方地址：https://github.com/fatedier/frp/ frp 中文文档：https://github.com/fatedier/frp/blob/dev/README_zh.md 我这里使用的是第三方，frpMgr极速安装包： https://github.com/Zo3i/frpMgr 在云主机里面安装 12wget -O - https://raw.githubusercontent.com/Zo3i/OCS/master/docker/docker-all2.sh | shwget -O - https://raw.githubusercontent.com/Zo3i/frpMgr/master/web/src/main/docker/final/run.sh | sh 安装完成登陆： 注：代码仅在Centos7,Debian9系统上通过测试 访问:你的服务器 ip:8999/frp 账号 admin 密码 12345678 查看日志命令： 121. docker ps2. docker logs -f --tail 10 java项目的容器I 如果需要修改代码,请自行编译 jar包重新部署即可… 详细FRP快捷配置面板 https://github.com/Zo3i/frpMgr/blob/master/README_zh.md 启动，停止，重启frps服务 123service frps statusservice frps stopservice frps restart","categories":[],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"https://webwlsong.github.io/tags/ubuntu/"},{"name":"linux","slug":"linux","permalink":"https://webwlsong.github.io/tags/linux/"},{"name":"frp","slug":"frp","permalink":"https://webwlsong.github.io/tags/frp/"},{"name":"内网穿透","slug":"内网穿透","permalink":"https://webwlsong.github.io/tags/内网穿透/"}]},{"title":"Ubuntu20.04.1关闭图形界面，使用tty登陆","slug":"2020/2020-08/2020-08-30-1","date":"2020-08-30T03:08:00.000Z","updated":"2020-09-09T11:15:36.129Z","comments":true,"path":"2020/08/30/2020/2020-08/2020-08-30-1/","link":"","permalink":"https://webwlsong.github.io/2020/08/30/2020/2020-08/2020-08-30-1/","excerpt":"","text":"Ubuntu 关闭图形界面，使用tty登陆 tty是终端设备的统称，TeleTYpe的一个老缩写。 123456# 关闭图形界面sudo systemctl set-default multi-user.targetsudo reboot# 开启图形界面sudo systemctl set-default graphical.targetsudo reboot 如果安装使用的是中文，字符显示乱码 安装zhcon 1sudo apt install zhcon","categories":[],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"https://webwlsong.github.io/tags/ubuntu/"},{"name":"linux","slug":"linux","permalink":"https://webwlsong.github.io/tags/linux/"}]},{"title":"更换了Hexo博客主题pure使用","slug":"2020/2020-08/2020-08-30","date":"2020-08-29T16:00:00.000Z","updated":"2020-09-09T11:15:36.129Z","comments":true,"path":"2020/08/29/2020/2020-08/2020-08-30/","link":"","permalink":"https://webwlsong.github.io/2020/08/29/2020/2020-08/2020-08-30/","excerpt":"","text":"重新换了个清新的blog模版 看着还不错，后续坚持分享更多有。欢迎大家留言","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://webwlsong.github.io/tags/hexo/"},{"name":"pure","slug":"pure","permalink":"https://webwlsong.github.io/tags/pure/"}]},{"title":"基于微服务器 docker下的gitlab安装","slug":"2020/2020-08/2020-08-29","date":"2020-08-28T16:00:00.000Z","updated":"2020-09-09T11:15:36.129Z","comments":true,"path":"2020/08/28/2020/2020-08/2020-08-29/","link":"","permalink":"https://webwlsong.github.io/2020/08/28/2020/2020-08/2020-08-29/","excerpt":"","text":"docker gitlab安装 我是在开发机器上面安装 第一步 在宿主机器上面安装创建gitlab配置目录 1mkdir -p /data/gitlab/&#123;config,logs,data&#125; 第二步 创建环境变量，指向本地宿主机存储gitlab配置的目录： 1export GITLAB_HOME=/data/gitlab 第三步 运行镜像，创建容器： 12345678docker run --detach \\--hostname 127.0.0.1 \\-p 8443:443 -p 8880:80 -p 8822:22 \\--name gitlab --restart always \\-v $GITLAB_HOME/config:/etc/gitlab \\-v $GITLAB_HOME/logs:/var/log/gitlab \\-v $GITLAB_HOME/data:/vat/opt/gitlab \\gitlab/gitlab-ce:latest 使用命令lsof -i 端口号 查看端口是否被使用 其中由于宿主机的22端口被sshd服务使用，所以改为映射8822端口。80端口被暂用了，改成8880 https 已经被占用了。 注意： mac 1024一下的端口号需要 root权限 第四步 配置gitlab 配置gitlab 容器生成后，根据需要修改gitlab的配置，直接进入宿主机本地映射的config目录，编辑gitlab.rb文件; gitlab.rb文件内，主要需要配置的选项如下： 12345678910111213## GitLab NGINXnginx[&apos;listen_port&apos;] = 80 # gitlab nginx 端口。默认端口为：80 ## GitLab Unicornunicorn[&apos;listen&apos;] = &apos;localhost&apos;unicorn[&apos;port&apos;] = 8080 #默认是8080端口 ## GitLab URL 配置http协议所使用的访问地址external_url GENERATED_EXTERNAL_URL&apos; # clone时显示的地址，gitlab 的域名 # 配置ssh协议所使用的访问地址和端口gitlab_rails[&apos;gitlab_ssh_host&apos;] = &apos;song.local&apos;gitlab_rails[&apos;gitlab_shell_ssh_port&apos;] = 8822 gitlab性能相关的选项如下： 123456789101112131415161718# 超时时间unicorn[&apos;worker_timeout&apos;] = 60 #不能低于2，否则卡死 worker=CPU核数+1 unicorn[&apos;worker_processes&apos;] = 2 # 减少数据库缓存大小 默认256，可适当改小 postgresql[&apos;shared_buffers&apos;] = &quot;256MB&quot; # 减少数据库并发数postgresql[&apos;max_worker_processes&apos;] = 8 # 减少sidekiq并发数sidekiq[&apos;concurrency&apos;] = 10 # 减少内存 unicorn[&apos;worker_memory_limit_min&apos;] = &quot;200 * 1 &lt;&lt; 20&quot;unicorn[&apos;worker_memory_limit_max&apos;] = &quot;300 * 1 &lt;&lt; 20&quot; 配置gitlab的邮箱服务： 1234567891011121314gitlab_rails[&apos;smtp_enable&apos;] = truegitlab_rails[&apos;smtp_address&apos;] = &quot;smtp.server&quot;gitlab_rails[&apos;smtp_port&apos;] = 465gitlab_rails[&apos;smtp_user_name&apos;] = &quot;smtp user&quot;gitlab_rails[&apos;smtp_password&apos;] = &quot;smtp password&quot;gitlab_rails[&apos;smtp_domain&apos;] = &quot;example.com&quot;gitlab_rails[&apos;smtp_authentication&apos;] = &quot;login&quot;gitlab_rails[&apos;smtp_enable_starttls_auto&apos;] = truegitlab_rails[&apos;smtp_openssl_verify_mode&apos;] = &apos;peer&apos; # If your SMTP server does not like the default &apos;From: gitlab@localhost&apos; you# can change the &apos;From&apos; with this setting.gitlab_rails[&apos;gitlab_email_from&apos;] = &apos;gitlab@example.com&apos;gitlab_rails[&apos;gitlab_email_reply_to&apos;] = &apos;noreply@example.com&apos; 配置完成后，重启gitlab容器即可。 1docker restart ####","categories":[],"tags":[{"name":"docker","slug":"docker","permalink":"https://webwlsong.github.io/tags/docker/"},{"name":"gitlab","slug":"gitlab","permalink":"https://webwlsong.github.io/tags/gitlab/"}]},{"title":"php 基准测试对比。","slug":"2017-06-01","date":"2017-05-31T16:00:00.000Z","updated":"2020-09-09T11:15:36.129Z","comments":true,"path":"2017/05/31/2017-06-01/","link":"","permalink":"https://webwlsong.github.io/2017/05/31/2017-06-01/","excerpt":"","text":"php7 相比 Php5.6 提升 2-3 倍。 PHP7-JIT 相比 PHP5.6 提升 8 倍。 如果作为 php 开发者连鸟哥都不认识，起码不是很合格吧。下面是鸟哥做的测试对比。 下面是鸟哥做的分享。 为什么选择 php7？","categories":[],"tags":[{"name":"php","slug":"php","permalink":"https://webwlsong.github.io/tags/php/"},{"name":"php-jit","slug":"php-jit","permalink":"https://webwlsong.github.io/tags/php-jit/"}]},{"title":"operator mono vs fira code","slug":"2017-05-27","date":"2017-05-26T16:00:00.000Z","updated":"2020-09-09T11:15:36.129Z","comments":true,"path":"2017/05/26/2017-05-27/","link":"","permalink":"https://webwlsong.github.io/2017/05/26/2017-05-27/","excerpt":"","text":"operator mono 和 fira code 两个字体是目前世界上最好的字体。 1：看看别人的介绍 Operator Mono &amp; Fira Code — The Best of Both Worlds 2：Laravel作者 Eric L. Barnes用的也是这个字体。作者在推特上面发布出了他的配置 3：operator mono 是收费字体。fira code是免费字体。 如果在mac 安装 fira code 可以使用命令 brew cask install font-fira-code 最后提供一个 operator mono下载地址 链接: https://pan.baidu.com/s/1nvynUXF 密码: kezv 4:完成之后效果","categories":[],"tags":[{"name":"operator mono","slug":"operator-mono","permalink":"https://webwlsong.github.io/tags/operator-mono/"},{"name":"fira code","slug":"fira-code","permalink":"https://webwlsong.github.io/tags/fira-code/"}]},{"title":"Nginx 限流","slug":"2017-04-28-1","date":"2017-04-27T16:00:00.000Z","updated":"2020-09-09T11:15:36.129Z","comments":true,"path":"2017/04/27/2017-04-28-1/","link":"","permalink":"https://webwlsong.github.io/2017/04/27/2017-04-28-1/","excerpt":"","text":"电商平台营销时候，经常会碰到的大流量问题, 除了做流量分流处理，可能还要做用户黑白名单、信誉分析，进而根据用户ip信誉权重做相应的流量拦截、限制流量。Nginx自身有的请求限制模块ngx_http_limit_req_module、流量限制模块ngx_stream_limit_conn_module基于令牌桶算法，可以方便的控制令牌速率，自定义调节限流，实现基本的限流控制。 对于提供下载的网站，肯定是要进行流量控制的，例如软件下载站、视频服务等。它也可以减少一些爬虫程序或者DDOS的攻击。 对这两个模块的介绍的文章也不少，这里转载一篇hopestar的文章: nginx限制IP连接数的范例参考， 因为他介绍的很简洁。 如何Nginx限制同一个ip的连接数，限制并发数目: 1. 限流 添加limit_zone和limit_req_zone; 这个变量只能在http使用 : 123vi /export/servers/nginx/conf/nginx.conf limit_zone one $binary_remote_addr 20m;limit_req_zone $binary_remote_addr zone=req_one:20m rate=12r/s; 添加limit_conn 和limit_req 这个变量可以在http, server, location使用 我是限制nginx上的所有服务，所以添加到http里面 （如果你需要限制部分服务，可在nginx/conf/domains里面选择相应的server或者location添加上便可） 12345vi /export/servers/nginx/conf/nginx.conf limit_zone one $binary_remote_addr 20m;limit_req_zone $binary_remote_addr zone=req_one:20m rate=12r/s;limit_conn one 10;limit_req zone=req_one burst=120; 参数详解(数值按具体需要和服务器承载能力设置,): 123456limit_zone，是针对每个变量(这里指IP，即$binary_remote_addr)定义一个存储session状态的容器。 这个示例中定义了一个20m的容器，按照32bytes/session， 可以处理640000个session。 limit_req_zone 与limit_zone类似。rate是请求频率. 每秒允许12个请求。limit_conn one 10 : 表示一个IP能发起10个并发连接数limit_req: 与limit_req_zone对应。burst表示缓存住的请求数。 示例： 123456789101112131415http&#123; limit_zone one $binary_remote_addr 20m; limit_req_zone $binary_remote_addr zone=req_one:20m rate=12r/s; limit_conn one 10; limit_req zone=req_one burst=120; server &#123; listen 80; server_name status.xxx.com ; location / &#123; stub_status on; access_log off; &#125; &#125;&#125; 重启nginx 1/export/servers/nginx/sbin/nginx -s reload 2. nginx白名单设置 以上配置会对所有的ip都进行限制，有些时候我们不希望对搜索引擎的蜘蛛或者某些自己的代理机过来的请求进行限制， 对于特定的白名单ip我们可以借助geo指令实现。 先在nginx的请求日志进行统计，查看那个ip的访问量比较大， 运行: 12cat access.log | grep \"03/Jun\" |awk '&#123;print $1&#125;'|sort |uniq -c|sort -nrk 1|head -n 10#列出访问日志里面在6月3号这天前10个访问量最大的ip. 接下来就可以对这些IP进行分析了。看哪些需要进行白名单设置。 12345678910111213141516http&#123; geo $limited &#123; # the variable created is $limited default 1; 127.0.0.1/32 0; 10.12.212.63 0; &#125; map $limited $limit &#123; 1 $binary_remote_addr; 0 \"\"; &#125; limit_zone one $binary_remote_addr 20m; limit_req_zone $limit zone=req_one:20m rate=20r/s; limit_conn one 10; limit_req zone=req_one burst=120;&#125; 上面两个需要用到map和geo模块，这是nginx自带的模块，有的运维喜欢把他们关闭，自己./sbin/nginx -V 留意一下。把配置的--whithout-XXX-module去掉重新编译一下就可以了。 上面这段配置的意思是： geo指令定义了一个白名单limited变量，默认值为1，如果客户端ip在上面的范围内，limited变量，默认值为1，如果客户端ip在上面的范围内，limited变量，默认值为1，如果客户端ip在上面的范围内，limited的值为0 使用map指令映射搜索引擎客户端的ip为空串，如果不是搜索引擎就显示本身真实的ip，这样搜索引擎ip就不能存到limit_req_zone内存session中，所以不会限制搜索引擎的ip访问 3. 获取客户端的真实IP 顺带一提，为了获取客户端的真实IP。该模块需要安装read_ip模块，运维应该默认有安装。没有的话也可自行安装： 配置方式相当简单，重新编译 Nginx 加上 --with-http_realip_module 参数，如： 123./configure --prefix=/opt/nginx --with-http_stub_status_module --with-pcre=../pcre-6.6 --with-http_realip_modulemakemake install 在server中增加: 123set_real_ip_from 192.168.1.0/24;set_real_ip_from 192.168.2.1;real_ip_header [X-Real-IP|X-Forwarded-For]; 需要说明的地方就是设置IP源的时候可以设置单个IP，也可以设置IP段，另外是使用X-Real-IP还是X-Forwarded-For，取决于前面的服务器有哪个头。 set_real_ip_from 设置的IP端可以让运维查看日志，看下你的请求是来自哪些ip段。 重新加载一下服务，差不多就OK了。 再查看日志的话，应该可以看到客户端的真实IP了。 注意：如果未安装该模块的话你的获取到的IP端可能是来自前端代理（如squid）的IP，结果就是多个用户被当成单个用户对待，导致应用不能响应。 再PS一下： 自测: 有条件的自己可以用ab或者webben自测一下。 未安装前压测的话，因为有大量请求，所以access.log会有大量日志，而error.log日志没有变化。 1234567➜ ~ webbench -c 30 -t 30 http://xxx.comWebbench - Simple Web Benchmark 1.5Copyright (c) Radim Kolar 1997-2004, GPL Open Source Software.Benchmarking: GET http://xxx.com 30 clients, running 30 sec.Speed=193468 pages/min, 1254317 bytes/sec.Requests: 96734 susceed, 0 failed. 安装后会发现很多超出的请求会返回503,所以access.log日志变化不快，error.log有大量记录,提示limit_reque缓住了多少请求。 1234567➜ ~ webbench -c 30 -t 30 http://xxxx.comWebbench - Simple Web Benchmark 1.5Copyright (c) Radim Kolar 1997-2004, GPL Open Source Software.Benchmarking: GET http://xxx.com 30 clients, running 30 sec.Speed=120 pages/min, 778 bytes/sec.Requests: 60 susceed, 0 failed.","categories":[],"tags":[{"name":"nginx","slug":"nginx","permalink":"https://webwlsong.github.io/tags/nginx/"}]},{"title":"Nginx 负载均衡策略","slug":"2017-04-28","date":"2017-04-27T16:00:00.000Z","updated":"2020-09-09T11:15:36.129Z","comments":true,"path":"2017/04/27/2017-04-28/","link":"","permalink":"https://webwlsong.github.io/2017/04/27/2017-04-28/","excerpt":"","text":"轮询（默认）每个web请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。 1234Upstream nginxDemo&#123; server 127.0.0.1:8001; server 127.0.0.1:8002;&#125; 最少链接web请求会被转发到连接数最少的服务器上。 12345Upstream nginxDemo&#123; least_conn; server 127.0.0.1:8001; server 127.0.0.1:8002;&#125; weight 权重指定轮询几率，weight和访问比率成正比，用 于后端服务器性能不均的情况，weight默认是1。 1234567#服务器A和服务器B的访问比例：2-1；比如有3个请求，前两个会访问A，第三个会访问B，其他的归着和轮询一样。Upstream nginxDemo&#123; least_conn; server 127.0.0.1:8001; server 127.0.0.1:8002;&#125; ip_hash每个请求按访问ip的hash值分配，这样同一客户端连续的Web请求都会被分发到同一服务器进行处理，可以解决session的问题。当后台服务器宕机时，会自动跳转到其它服务器。基于weight的负载均衡和基于ip_hash的负载均衡可以组合在一起使用。 12345ip_hash;Upstream nginxDemo&#123; server 127.0.0.1:8001 weight=2; #服务器A server 127.0.0.1:8002; #服务器B&#125; url_hash（第三方）url_hash是nginx的第三方模块，nginx本身不支持，需要打补丁。nginx按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存服务器、文件服务器、静态服务器时比较有效。缺点是当后端服务器宕机的时候，url_hash不会自动跳转的其他缓存服务器，而是返回给用户一个503错误。 12345Upstream nginxDemo&#123; server 127.0.0.1:8001 weight=2; #服务器A server 127.0.0.1:8002; #服务器B hash $request_url;&#125; fair（第三方）按后端服务器的响应时间来分配请求，响应时间短的优先分配。 12345Upstream nginxDemo&#123; server 127.0.0.1:8001 weight=2; #服务器A server 127.0.0.1:8002; #服务器B hair;&#125;","categories":[],"tags":[{"name":"nginx","slug":"nginx","permalink":"https://webwlsong.github.io/tags/nginx/"}]},{"title":"IntelliJ Idea 2017 免费激活方法","slug":"2017-04-27","date":"2017-04-26T16:00:00.000Z","updated":"2020-09-09T11:15:36.129Z","comments":true,"path":"2017/04/26/2017-04-27/","link":"","permalink":"https://webwlsong.github.io/2017/04/26/2017-04-27/","excerpt":"","text":"第一种方法： 到网站 http://idea.lanyus.com/ 获取注册码。 第二种方法： 首先：0.0.0.0 account.jetbrains.com 添加到hosts 填入下面的license server: http://intellij.mandroid.cn/ http://idea.imsxm.com/ http://idea.iteblog.com/key.php 以上方法验证均可以","categories":[],"tags":[{"name":"phpstrom","slug":"phpstrom","permalink":"https://webwlsong.github.io/tags/phpstrom/"},{"name":"jetbrains","slug":"jetbrains","permalink":"https://webwlsong.github.io/tags/jetbrains/"}]},{"title":"php nodejs nginx 进程模型对比","slug":"2017-04-25","date":"2017-04-24T16:00:00.000Z","updated":"2020-09-09T11:15:36.129Z","comments":true,"path":"2017/04/24/2017-04-25/","link":"","permalink":"https://webwlsong.github.io/2017/04/24/2017-04-25/","excerpt":"","text":"PHP 进程模型 PHP-FPM 是 PHP 针对 FastCGI 协议的具体实现，也是 PHP 在多种服务器端应用编程端口（SAPI：cgi、fast-cgi、cli、isapi、apache）里使用最普遍、性能最佳的一款进程管理器。 PHP-FPM 这种模型是非常典型的多进程同步模型，意味着一个请求对应一个进程线程，并且 IO 是同步阻塞的。所以尽管 PHP-FPM 维护着独立的 CGI 进程池、系统也可以很轻松的管理进程的生命周期， 受制于服务器的硬件设施，PHP-FPM 需要指定合理的 php-fpm.conf 配置： 12345pm.max_children # 子进程最大数pm.start_servers # 启动时的子进程数pm.min_spare_servers # 最小空闲进程数，空闲进程不够时自动补充pm.max_spare_servers # 最大空闲进程数，空闲进程超过时自动清理pm.max_requests = 1000 # 子进程请求数阈值，超过后自动回收 PHP 进程本身并不存在内存泄露的问题，每个进程完成请求处理后会回收内存，但是并不会释放给操作系统，这就导致大量内存被 PHP-FPM 占用而无法释放，请求量升高时性能骤降。 所以 PHP-FPM 需要控制单个子进程请求次数的阈值。很多人会误以为 max_requests 控制了进程的并发连接数，实际上 PHP-FPM 模式下的进程是单一线程的，请求无法并发。这个参数的真正意义是提供请求计数器的功能，超过阈值数目后自动回收，缓解内存压力。 nginx进程模型 Nginx 是非阻塞IO &amp; IO复用模型，通过操作系统提供的类似 epoll 的功能，可以在一个线程里处理多个客户端的请求。 Nginx 的进程就是线程，即每个进程里只有一个线程，但这一个线程可以服务多个客户端。 nginx在启动后，会有一个master进程和多个worker进程。master进程主要用来管理worker进程，包含：接收来自外界的信号，向各worker进程发送信号，监控worker进程的运行状态，当worker进程退出后(异常情况下)，会自动重新启动新的worker进程。而基本的网络事件，则是放在worker进程中来处理了。多个worker进程之间是对等的，他们同等竞争来自客户端的请求，各进程互相之间是独立的。一个请求，只可能在一个worker进程中处理，一个worker进程，不可能处理其它进程的请求。worker进程的个数是可以设置的，一般我们会设置与机器cpu核数一致，这里面的原因与nginx的进程模型以及事件处理模型是分不开的 因此才有了异步非阻塞的事件处理机制。具体到系统调用就是像select/poll/epoll/kqueue这样的系统调用。他们提供了一种机制，让你可以同时监控多个事件，调用他们是阻塞的，但可以设置超时时间，在超时时间之内，如果有事件准备好了，就返回。这种机制解决了我们上面两个问题。 以epoll为例：当事件没有准备好时，就放入epoll里面。如果有事件准备好了，那么就去处理；如果事件返回的是EAGAIN，那么继续将其放入epoll里面。从而，只要有事件准备好了，我们就去处理她，只有当所有时间都没有准备好时，才在epoll里面等着。这样，我们就可以并发处理大量的并发了，当然，这里的并发请求，是指未处理完的请求，线程只有一个，所以同时能处理的请求当然只有一个了，只是在请求间进行不断地切换而已，切换也是因为异步事件未准备好，而主动让出的。这里的切换是没有任何代价，你可以理解为循环处理多个准备好的事件，事实上就是这样的。 nodejs 进程模型 我们都知道nodejs最大的特点就是单进程、无阻塞运行，并且是异步事件驱动的。Nodejs的这些特性能够很好的解决一些问题，例如在服务器开发中，并发的请求处理是个大问题，阻塞式的函数会导致资源浪费和时间延迟。通过事件注册、异步函数，开发人员可以提高资源的利用率，性能也会改善。既然Node.js采用单进程、单线程模式，那么在如今多核硬件流行的环境中，单核性能出色的Nodejs如何利用多核CPU呢？创始人Ryan Dahl建议，运行多个Nodejs进程，利用某些通信机制来协调各项任务。目前，已经有不少第三方的Node.js多进程支持模块发布，而NodeJS 0.6.x 以上的版本提供了一个cluster模块 ,允许创建“共享同一个socket”的一组进程,用来分担负载压力。","categories":[],"tags":[{"name":"php","slug":"php","permalink":"https://webwlsong.github.io/tags/php/"},{"name":"nodejs","slug":"nodejs","permalink":"https://webwlsong.github.io/tags/nodejs/"},{"name":"nginx","slug":"nginx","permalink":"https://webwlsong.github.io/tags/nginx/"}]},{"title":"测试一下 qq和淘宝网页的测试","slug":"2017-04-17","date":"2017-04-16T16:00:00.000Z","updated":"2020-09-09T11:15:36.129Z","comments":true,"path":"2017/04/16/2017-04-17/","link":"","permalink":"https://webwlsong.github.io/2017/04/16/2017-04-17/","excerpt":"","text":"为什么做这个测试？最近有人你们的app接口能支持多大的并发，能支持多少的用户。 答： 这个本身就是个伪命题，没有场景话，很难回答。就好像，你们怎么做优化，这本身也是个伪命题。 如果要回答，网上google一下，有很多，问题在于你们的场景能用的到吗？如果要谈，这个很大的话题。 每个话题展开都能谈很久。 延迟分析 同城机房网络(0.5ms~2ms) max(1000qps) jvm-gc(50ms左右) max(20qps) 如果是异地机房，例如北京到上海机房，一次网络往返可能就13～20毫秒延迟。max(50qps) ![测试图](2017-04-17 at 14.04.47.gif) （测试图）","categories":[],"tags":[{"name":"性能测试","slug":"性能测试","permalink":"https://webwlsong.github.io/tags/性能测试/"}]},{"title":"docker ubuntu ping source 不能使用","slug":"2016-11-28","date":"2016-11-27T16:00:00.000Z","updated":"2020-09-09T11:15:36.129Z","comments":true,"path":"2016/11/27/2016-11-28/","link":"","permalink":"https://webwlsong.github.io/2016/11/27/2016-11-28/","excerpt":"","text":"使用docker 拉取ubunut 镜像 我本地使用的ubuntu 镜像版本如下： 1234sh-4.3# cat /etc/issueUbuntu 16.04.1 LTS \\n \\lsh-4.3# 拉取ubuntu进行，你会发现有的镜像Ping都不通 解决方法： apt-get update 更新源 source 和 ubunut的代码补全也不能使用 shell脚本中source 时提示 source: not found Debian和Ubuntu中，/bin/sh默认已经指向dash，这是一个不同于bash的shell，它主要是为了执行脚本而出现，而不是交互，它速度更快，但功能相比bash要少很多，语法严格遵守POSIX标准 dash不是为交互而生的，所以我们在使用过程中还是习惯的修改成bash 123ls -l /bin/sh 显示 /bin/sh -&gt;dash 显示使用的是dash 修改默认的shell 123sudo dpkg-reconfigure dash再次检查一下， ls /bin/sh -al 发现软链接指向/bin/bash 恢复ubuntu bash下的自动补全 123451. 确认/etc/bash_completion是否存在，如果没有就安装一个：2. apt-get install bash-completion在用户的shell中运行：3. source /etc/bash_completion 添加新的用户 ubuntn下面 1234567891011useradd -m username //ubuntu 自动创建用户目录passwd username //创建密码usermod -a -G sudo username //用户拥有权限ubuntu 默认的是dash shell修改成 bashvi /etc/passwd 1.username:x:1000:1000::/home/username修成成如下：2. username:x:1000:1000::/home/username:/bin/bash","categories":[],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"https://webwlsong.github.io/tags/ubuntu/"},{"name":"docker","slug":"docker","permalink":"https://webwlsong.github.io/tags/docker/"}]},{"title":"解决go delve 不能使用 OS X cannot get thread count","slug":"2016-11-26","date":"2016-11-25T16:00:00.000Z","updated":"2020-09-09T11:15:36.129Z","comments":true,"path":"2016/11/25/2016-11-26/","link":"","permalink":"https://webwlsong.github.io/2016/11/25/2016-11-26/","excerpt":"","text":"go Delve 报错 mac 解决方法如下： 我的go版本 ：go version go1.7.3 darwin/amd64 https://github.com/derekparker/delve/issues/645 ` go into your GOPATH create folder $GOPATH/src/github.com/derekparker/, and go into this folder. ‘cd $GOPATH/src/github.com/derekparker/’ git clone https://github.com/derekparker/delve.git cd delve git fetch origin pull/665/head git checkout FETCH_HEAD CERT=dlv-cert make install `","categories":[],"tags":[{"name":"go","slug":"go","permalink":"https://webwlsong.github.io/tags/go/"},{"name":"delve","slug":"delve","permalink":"https://webwlsong.github.io/tags/delve/"}]},{"title":"用swoole TCP Server 和mongodb做数据备份和恢复","slug":"mongo-php-error","date":"2016-05-18T10:52:40.000Z","updated":"2020-09-09T11:15:36.137Z","comments":true,"path":"2016/05/18/mongo-php-error/","link":"","permalink":"https://webwlsong.github.io/2016/05/18/mongo-php-error/","excerpt":"","text":"应用场景是，单个用户写的数据是8-10条/S JSON数据包 采用架构如下图所示： 采用的是 php7.0.6 swoole-1.8.5版本 php扩展mongodb1.1.6 而目前mongo-1.6.14不支持php7 这样导致连接Mongo函数不一样，后面会讲到。 服务器 Ubuntu 14.04 64位 2核 4G 阿里云的Mongodb服务器 到目前阿里云Mongodb还不支持sharding,后续会进行支持。目前是使用双节点。摘录MongoDB杭州用户交流会的一段话: 阿里云目前已提供对MongoDB复制集（Replica Set）的支持，默认会为用户创建包含3个数据节点的复制集，其中一个Primary、一个Secondary，以及一个Hidden节点。Primary、Secondary对用户可见，用户可以自定义ReadPreference，Hidden节点对用户不可见，目前主要用于实例数据备份以及自动的failover，当有Primary或Secondary节点挂掉时，Hidden会被自动切换为Secondary，保证用户的服务不受影响。 mongodb服务器 阿里云服务器目前只支持ECS访问不支持外网方面 [公网连接mongodb windows篇](https://help.aliyun.com/knowledge_detail/13052608.html#通过公网连接云数据库MongoDB--ECS Windows篇) [公网连接mongodb linux篇](https://help.aliyun.com/knowledge_detail/13052572.html#通过公网连接云数据库MongoDB--ECS Linux篇) 用如下命令检测是否连上mongodb ping dds-xxxxxxxx.mongodb.rds.aliyuncs.com telnet dds-xxxxxxxxxxxx.mongodb.rds.aliyuncs.com 3717 mongo --host dds-xxxxxxxxxxxxx1.mongodb.rds.aliyuncs.com:3717 --authenticationDatabase admin -u root -p mongo --host dds-xxxxxxxxxxxxxx2.mongodb.rds.aliyuncs.com:3717 --authenticationDatabase admin -u root -p 如果本身server服务器用的ECS，还是要设置一下， 搭建TCP-SEVER服务器 买好服务器之后习惯性的把服务器服务升级到最新。（这个是强迫症） 123$ apt-get update $ apt-get upgrade 安装最新的php7.0.6环境 12345678910111213141516171819202122232425262728293031323334353637apt-get install python-software-propertiesapt-get install software-properties-commonLC_ALL=C.UTF-8 add-apt-repository ppa:ondrej/phpapt-get updateapt-cache show php7.0-dev Package: php7.0-devSource: php7.0Priority: optionalSection: phpInstalled-Size: 4658Maintainer: Debian PHP Maintainers &lt;pkg-php-maint@lists.alioth.debian.org&gt;Architecture: amd64Version: 7.0.6-12+donate.sury.org~trusty+1Recommends: dh-php, pkg-php-toolsDepends: autoconf (&gt;= 2.63), automake (&gt;= 1.11), libpcre3-dev, libssl-dev, php7.0-cli (&gt;= 7.0.6-12+donate.sury.org~trusty+1), php7.0-common (= 7.0.6-12+donate.sury.org~trusty+1), shtool, libtoolFilename: pool/main/p/php7.0/php7.0-dev_7.0.6-12+donate.sury.org~trusty+1_amd64.debSize: 505784MD5sum: bb75fadf2fc0bae22d7a26999b9ac0e2SHA1: a85e13a259faae1377813d7b1e5c344c8ede8d09SHA256: 79617d3b79e054129a2e980534885ab794ec18c5052894e71d1da37ec07b2affDescription-en: Files for PHP7.0 module development This package provides the files from the PHP7.0 source needed for compiling additional modules.PHP (recursive acronym for PHP: Hypertext Preprocessor) is a widely-used open source general-purpose scripting language that is especially suited for web development and can be embedded into HTML.Description-md5: cab4eaaf141b1f52bc2814eea2492ab2apt-get install php7.0-dev 安装mongo扩展 和swoole扩展 1234567891011121314151617181920212223242526272829使用pecl进行安装mongo和swoole扩展。这里记住是mongodb扩展不是mongo扩展。这两个扩展在使用上面不一样，后面会讲到。这里我们安装mongodb搜索mongodb$ pecl search mongopecl库更新到最新$ pecl channel-update pecl.php.net安装mongodb$ pecl install mongodb问题：1. 这里如果安装mongo会提示不支持Php7.0以上版本： pecl/mongo requires PHP (version &gt;= 5.3.0, version &lt;= 5.99.99), installed version is 7.0.6-12+donate.sury.org~trusty+12. configure: error: Cannot find OpenSSL&apos;s libraries 解决方法： ln -s /usr/lib/x86_64-linux-gnu/libssl.so /usr/lib安装swoole$ pecl install swoole查找php.ini 把swoole.so和mongodb加入进去$ php --ini $ php -ri|grep swoole PHP swoole代码 1234567891011121314151617181920212223242526272829303132333435$serv = new swoole_server(\"0.0.0.0\", 9501);$serv-&gt;set(array( 'worker_num' =&gt; 8, //工作进程数量 'daemonize' =&gt; false, //是否作为守护进程));$serv-&gt;on('connect', function ($serv, $fd) &#123; echo \"Client:Connect.\\n\";&#125;);$serv-&gt;on('receive', function ($serv,$fd, $from_id, $data) &#123; $arr = json_decode($data); //$array=array('column_name'=&gt;'col'.rand(100,999),'column_exp'=&gt;'xiaocai'); $connection = new MongoClient(\"mongodb://root:密码@主机ID1.mongodb.rds.aliyuncs.com:3717,主机2.mongodb.rds.aliyuncs.com:3717/admin?replicaSet=副本集名称\"); // $connection = new MongoClient(\"mongodb://localhost:27017\"); var_dump($connection); $roomid = \"roomid\".'_123'; $collection = $connection-&gt;test-&gt;$roomid; $collection-&gt;insert($arr); $document = $collection-&gt;findOne(); var_dump($document); $serv-&gt;send($fd, 'Swoole: ' . $data); $serv-&gt;close($fd);&#125;);$serv-&gt;on('close', function ($serv, $fd) &#123; echo \"Client: Close.\\n\";&#125;);$serv-&gt;start(); 如果执行上面的代码的话，会报PHP Fatal error: Uncaught Error: Class 'MongoClient' not found 这里要说明一下MongoClient是扩展Mongo的内置函数。 可以通过 1print_r(get_declared_classes()); 查看函数列表 Mongo的函数列表 123456789101112131415161718192021222324252627282930313233343536[156] =&gt; MongoClient[157] =&gt; Mongo[158] =&gt; MongoDB[159] =&gt; MongoCollection[160] =&gt; MongoCursor[161] =&gt; MongoCommandCursor[162] =&gt; MongoGridFS[163] =&gt; MongoGridFSFile[164] =&gt; MongoGridFSCursor[165] =&gt; MongoWriteBatch[166] =&gt; MongoInsertBatch[167] =&gt; MongoUpdateBatch[168] =&gt; MongoDeleteBatch[169] =&gt; MongoId[170] =&gt; MongoCode[171] =&gt; MongoRegex[172] =&gt; MongoDate[173] =&gt; MongoBinData[174] =&gt; MongoDBRef[175] =&gt; MongoException[176] =&gt; MongoConnectionException[177] =&gt; MongoCursorException[178] =&gt; MongoCursorTimeoutException[179] =&gt; MongoGridFSException[180] =&gt; MongoResultException[181] =&gt; MongoWriteConcernException[182] =&gt; MongoDuplicateKeyException[183] =&gt; MongoExecutionTimeoutException[184] =&gt; MongoProtocolException[185] =&gt; MongoTimestamp[186] =&gt; MongoInt32[187] =&gt; MongoInt64[188] =&gt; MongoLog[189] =&gt; MongoPool[190] =&gt; MongoMaxKey[191] =&gt; MongoMinKey Mongodb的函数列表 1234567891011121314151617181920212223242526272829303132[100] =&gt; MongoDB\\Driver\\Command [101] =&gt; MongoDB\\Driver\\Cursor [102] =&gt; MongoDB\\Driver\\CursorId [103] =&gt; MongoDB\\Driver\\Manager [104] =&gt; MongoDB\\Driver\\Query [105] =&gt; MongoDB\\Driver\\ReadConcern [106] =&gt; MongoDB\\Driver\\ReadPreference [107] =&gt; MongoDB\\Driver\\Server [108] =&gt; MongoDB\\Driver\\BulkWrite [109] =&gt; MongoDB\\Driver\\WriteConcern [110] =&gt; MongoDB\\Driver\\WriteConcernError [111] =&gt; MongoDB\\Driver\\WriteError [112] =&gt; MongoDB\\Driver\\WriteResult [113] =&gt; MongoDB\\Driver\\Exception\\LogicException [114] =&gt; MongoDB\\Driver\\Exception\\RuntimeException [115] =&gt; MongoDB\\Driver\\Exception\\UnexpectedValueException [116] =&gt; MongoDB\\Driver\\Exception\\InvalidArgumentException [117] =&gt; MongoDB\\Driver\\Exception\\ConnectionException [118] =&gt; MongoDB\\Driver\\Exception\\AuthenticationException [119] =&gt; MongoDB\\Driver\\Exception\\SSLConnectionException [120] =&gt; MongoDB\\Driver\\Exception\\WriteException [121] =&gt; MongoDB\\Driver\\Exception\\BulkWriteException [122] =&gt; MongoDB\\Driver\\Exception\\ExecutionTimeoutException [123] =&gt; MongoDB\\Driver\\Exception\\ConnectionTimeoutException [124] =&gt; MongoDB\\BSON\\Binary [125] =&gt; MongoDB\\BSON\\Javascript [126] =&gt; MongoDB\\BSON\\MaxKey [127] =&gt; MongoDB\\BSON\\MinKey [128] =&gt; MongoDB\\BSON\\ObjectID [129] =&gt; MongoDB\\BSON\\Regex [130] =&gt; MongoDB\\BSON\\Timestamp [131] =&gt; MongoDB\\BSON\\UTCDateTime 所以要使用Php7.0以上版本需要重新写连接mongdo的数据库 查找php文档Mongodb driver 修改成为mongodb的一个demo 连接修改代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162$serv = new swoole_server(\"0.0.0.0\", 9501);$serv-&gt;set(array( 'worker_num' =&gt; 8, //工作进程数量 'daemonize' =&gt; false, //是否作为守护进程));$serv-&gt;on('connect', function ($serv, $fd) &#123; echo \"Client:Connect.\\n\";&#125;);$serv-&gt;on('receive', function ($serv, $fd, $from_id, $data) &#123; $arr = json_decode($data); $bulk = new MongoDB\\Driver\\BulkWrite(['ordered' =&gt; true]); $bulk-&gt;insert($arr); $connection = new MongoDB\\Driver\\Manager(\"mongodb://localhost:27017\"); try &#123; $result = $connection-&gt;executeBulkWrite('test.roomid', $bulk); &#125; catch (MongoDB\\Driver\\Exception\\BulkWriteException $e) &#123; $result = $e-&gt;getWriteResult(); if ($writeConcernError = $result-&gt;getWriteConcernError()) &#123; printf(\"%s (%d): %s\\n\", $writeConcernError-&gt;getMessage(), $writeConcernError-&gt;getCode(), var_export($writeConcernError-&gt;getInfo(), true)); &#125; // Check if any write operations did not complete at all foreach ($result-&gt;getWriteErrors() as $writeError) &#123; printf(\"Operation#%d: %s (%d)\\n\", $writeError-&gt;getIndex(), $writeError-&gt;getMessage(), $writeError-&gt;getCode() ); &#125; &#125; catch (MongoDB\\Driver\\Exception\\Exception $e) &#123; printf(\"Other error: %s\\n\", $e-&gt;getMessage()); exit;&#125; printf(\"Inserted %d document(s)\\n\",$result-&gt;getInsertedCount()); printf(\"Updated %d document(s)\\n\",$result-&gt;getModifiedCount()); $serv-&gt;send($fd, 'Swoole: ' . $data); $serv-&gt;close($fd);&#125;);$serv-&gt;on('close', function ($serv, $fd) &#123; echo \"Client: Close.\\n\"; &#125;);$serv-&gt;start(); 模拟请求数据 1netcat 127.0.0.1 9501 END","categories":[],"tags":[{"name":"mongo","slug":"mongo","permalink":"https://webwlsong.github.io/tags/mongo/"},{"name":"php-mongo","slug":"php-mongo","permalink":"https://webwlsong.github.io/tags/php-mongo/"},{"name":"swoole","slug":"swoole","permalink":"https://webwlsong.github.io/tags/swoole/"},{"name":"tcp","slug":"tcp","permalink":"https://webwlsong.github.io/tags/tcp/"}]},{"title":"go基本语法","slug":"go-sty01","date":"2016-04-28T07:25:02.000Z","updated":"2020-09-09T11:15:36.137Z","comments":true,"path":"2016/04/28/go-sty01/","link":"","permalink":"https://webwlsong.github.io/2016/04/28/go-sty01/","excerpt":"","text":"变量和赋值 在go 语言中声明和赋值是分开的需要两步，也可以写成一步 1234var a intvar b boola = 5b = false 或者写成一步 12a :=5b :=false 多个var声明可以成组 1234var( x int b bool) 具备相同的类型多个变量可以在一行内完成声明：var x,y int 让x 和 y 都是 int 类型变量。同样也可以平行赋值 1a,b := 20,16 这样让a和b的值分别是20和16 一些特殊的变量名是_(下划线)。标示任何赋值给他的都会抛弃掉。 例如： 1_,b :=1,2 这样抛弃掉1 把b赋值为2. 数字类型(Number) 数值类型有三种，一种是整数类型，另外一种是浮点型, 还有一种是虚数类型。正整数和零统称为: 无符号整型, 而负整数称为: 有符号整型。 无符号类型能够表示正整数和零。而有符号类型除了能够表示正整数和零外，还可以表示负整数。 另外还有一些别名类型，比如byte类型，这个类型和uint8是一样的，表示字节类型。另外一个是rune类型，这个类型和int32是一样的，用来表示unicode的代码点，就是unicode字符所对应的整数。 Go还定义了三个依赖系统的类型，uint，int和uintptr。因为在32位系统和64位系统上用来表示这些类型的位数是不一样的。 12345678对于32位系统uint=uint32int=int32uintptr为32位的指针对于64位系统uint=uint64int=int64uintptr为64位的指针 至于类型后面跟的数字8，16，32或是64则表示用来表示这个类型的位不同，位越多，能表示的整数范围越大。 比如对于用N位来表示的整数，如果是有符号的整数，能够表示的整数范围为-2^(N-1) ~ 2^(N-1)－1；如果是无符号的整数，则能表示的整数范围为0 ～ 2^(N-1)。 Go的浮点数类型有两种，float32和float64。float32又叫单精度浮点型，float64又叫做双精度浮点型。其最主要的区别就是小数点后面能跟的小数位数不同. 另外Go还有两个其他语言所没有的类型，虚数类型。complex64和complex128。 对于数值类型，其所共有的操作为加法(＋)，减法(－)，乘法(＊)和除法(/)。另外对于整数类型，还定义了求余运算(%) 123456789101112package mainimport ( \"fmt\")func main() &#123; var a float64 = 12 var b float64 = 3 fmt.Println(a % b)&#125;","categories":[],"tags":[{"name":"go","slug":"go","permalink":"https://webwlsong.github.io/tags/go/"},{"name":"golang","slug":"golang","permalink":"https://webwlsong.github.io/tags/golang/"}]},{"title":"架构设计图","slug":"hw-jg","date":"2016-04-21T09:51:31.000Z","updated":"2020-09-09T11:15:36.137Z","comments":true,"path":"2016/04/21/hw-jg/","link":"","permalink":"https://webwlsong.github.io/2016/04/21/hw-jg/","excerpt":"","text":"今天抽点时间把产品架构图给画出来了。","categories":[],"tags":[{"name":"架构","slug":"架构","permalink":"https://webwlsong.github.io/tags/架构/"}]},{"title":"创业公司入职3年小结","slug":"ranyao-chuangye","date":"2016-04-20T14:07:23.000Z","updated":"2020-09-09T11:15:36.137Z","comments":true,"path":"2016/04/20/ranyao-chuangye/","link":"","permalink":"https://webwlsong.github.io/2016/04/20/ranyao-chuangye/","excerpt":"","text":"在创业公司3年多，学到了很多东西，也历练了很多，也见识了很多，后面会专门写几篇关于我在创业公司经历，大致从产品迭代开发，创业公司喜欢什么类型的人才，怎么在创业公司工作几个方面来介绍。本篇主要是入职3年小结 我们的产品在使用和用过那些技术 服务器端：PHP语言 数据库：MYSQL 缓存 redis memcache Android: Android原生 IOS: Object-c, Swift PC: c# WPF MVVM 流媒体： C,C++ SRS和自建RTMP-server,webRTC 服务器：阿里云云服务 （20+台） 云存储： 七牛 第三方厂家：云信IM和短信，SendCloud（邮件）极光推送（消息）Openfire, bugtags,友盟，支付支付和微信支付 后面想到在补充 入职的第一年 2013年2-3月份开始着手做教育产品，往往产品模型和软件架构是密切相关的，第一年我们只做了Android Pad，是一个大而全的产品封闭性的产品。起初软硬件都打算做的，先从软件做起，那个时候开模没有100W都很难做。所以当时公司经理和技术总监决定从软件开始做起，做了仿launcher,里面可以嵌入自己的App,其他的厂家的App,类似一个Android Rom的一个东西。当时做了及时问和考试苑。那个时候我主要负责服务器端开发，负责服务器基础架构，技术选型，服务器端人员招聘等工作。说白了，就是一个主程序员。 是否使用云服务器还是仔细斟酌考虑，采用自购服务器托管（当时主流），还是用云服务器。通过测试几家云服务器商（Ucloud,AWS,阿里云）,最终选择了阿里云，即使当时有很多对云服务器有很多谩骂声，但是针对我们小企业来说，云服务器是个不二的选择，至今我们都认为是正确的选择。这里还有个小插曲，我们在通宵测试对比Ucloud，那天晚上他们服务器正好升级，白忙活了。 云存储MFS的年代，当时也测试对比又拍云和七牛还有阿里云的OSS存储。 入职第二年 公司经理和技术总监离职，大股东进入，因为表现比较好，转升为技术总监。产品方向转向做移动App。还是以Android Pad为主，实现双向互动。我们也从小的办公场地搬到一个大的办公场地，开始了招兵买马。陆陆续续 流媒体组，测试组，设计组也细化开来分成UI和UE。流媒体部分还从做监控行业找到一个从业10来年经验的一个同事（却为后面埋下祸根）。由8-9个研发团队翻了了一倍，15-16个 这一年我们做了很多基础架构方面的事情，jenkins集成发布和测试，使用jenkins打包android。由原生git管理，迁移到gitlab，使用git flow 去管理。我也由ubuntu转成MAC平台开发。把云存储由阿里云OSS转向到七牛。（这个上周阿里云过来拜访来提到这个事情，起初对OSS不是很重视，出了很多问题）.那一年我们还完善了考试苑web端的开发，以及移动的考试苑api，和当时梯子网类似，同时还上了微课集模块，也已经在着手做教育云盘。 这一年我们公司也做了几次大的活动，包括和一些其他公司合作共赢开发，资源互换等尝试。这一年我们又有一次深刻的通宵经历，全司通宵修改版本，为第二天发布会做准备。虽然很辛苦，但是还是很快乐。 这一年我们还开始认识到手机应该是主流，同时要启动ios的开发。这一年结束之后不是很理想，陆续有人提出离职。也是这一年开始了解Docker方面的。 入职第三年 这一年最苦的时候服务器端只剩下我一人，同年5月我们获得了中信证券，银河证券 A轮 3000W的融资，后期慢慢有把这个团队重新组建起来，在后来我就从服务器端退出来，交给一个PHP资深的同事负责（英语比国语说的好 在互联网10来年经验的人），这一年服务器端进行了一次架构升级，同年我们开始从内部选拔人员转做IOS开发，组建IOS组，从Android和流媒体组自愿转岗到IOS，有一个经验非常丰富的同时带领，也是我招聘进来最得意的一位同事，技术非常全面。也是天天动听比较早期的员工。经历过创业和在大公司是完全不同的人。 流媒体也从原来的只支持Android，向全端支持，进行一次架构升级。Android端也进行了一次软件架构的升级。 为了优化书写感知，同年8月我们启动PC版本的开发。B/S和C/S架构上面抉择，最终我们选择了C/S架构的PC端。主要是考虑到和第三方手写板兼容性更好，B/S架构还的需求写插件支持才可以。 起初没有人会开发C/S或者我们在这个方面都没有经验，现在做WPF或者WCF的人少之又少，采用外包的方式。后面发现作为公司的产品外包是根本行不通，在产品不断的要进行修改，外包根本满足不了我们的需求。最后还的重新组建PC团队。补充流媒体团队的实力，流媒体中间件人员，主要做流媒体和M的对接工作。版本比较的多，测试人员我们也的扩充。研发团队扩展到目前团队23人。 后面公司也收购了一个市场团队。专做市场推广。 先写到这里吧","categories":[],"tags":[]},{"title":"开篇","slug":"开篇","date":"2016-04-20T06:33:43.000Z","updated":"2020-09-09T11:15:36.137Z","comments":true,"path":"2016/04/20/开篇/","link":"","permalink":"https://webwlsong.github.io/2016/04/20/开篇/","excerpt":"","text":"blog开篇 从2006年一直写到2013年1月6号最后一篇，总共500多篇。虽然Blog建了很长时间了，一直想继续去写，出于没有太时间去整理，原因baidu blog关闭了之后在也没有更新一遍Blog。作为一个老码农，总有个情怀，把自己项目中遇到的问题给记录记下来，看到好的文章转载收藏。","categories":[],"tags":[]}],"categories":[{"name":"test","slug":"test","permalink":"https://webwlsong.github.io/categories/test/"}],"tags":[{"name":"test","slug":"test","permalink":"https://webwlsong.github.io/tags/test/"},{"name":"树莓派","slug":"树莓派","permalink":"https://webwlsong.github.io/tags/树莓派/"},{"name":"go","slug":"go","permalink":"https://webwlsong.github.io/tags/go/"},{"name":"c","slug":"c","permalink":"https://webwlsong.github.io/tags/c/"},{"name":"c++","slug":"c","permalink":"https://webwlsong.github.io/tags/c/"},{"name":"内存","slug":"内存","permalink":"https://webwlsong.github.io/tags/内存/"},{"name":"堆栈","slug":"堆栈","permalink":"https://webwlsong.github.io/tags/堆栈/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://webwlsong.github.io/tags/ubuntu/"},{"name":"linux","slug":"linux","permalink":"https://webwlsong.github.io/tags/linux/"},{"name":"frp","slug":"frp","permalink":"https://webwlsong.github.io/tags/frp/"},{"name":"内网穿透","slug":"内网穿透","permalink":"https://webwlsong.github.io/tags/内网穿透/"},{"name":"hexo","slug":"hexo","permalink":"https://webwlsong.github.io/tags/hexo/"},{"name":"pure","slug":"pure","permalink":"https://webwlsong.github.io/tags/pure/"},{"name":"docker","slug":"docker","permalink":"https://webwlsong.github.io/tags/docker/"},{"name":"gitlab","slug":"gitlab","permalink":"https://webwlsong.github.io/tags/gitlab/"},{"name":"php","slug":"php","permalink":"https://webwlsong.github.io/tags/php/"},{"name":"php-jit","slug":"php-jit","permalink":"https://webwlsong.github.io/tags/php-jit/"},{"name":"operator mono","slug":"operator-mono","permalink":"https://webwlsong.github.io/tags/operator-mono/"},{"name":"fira code","slug":"fira-code","permalink":"https://webwlsong.github.io/tags/fira-code/"},{"name":"nginx","slug":"nginx","permalink":"https://webwlsong.github.io/tags/nginx/"},{"name":"phpstrom","slug":"phpstrom","permalink":"https://webwlsong.github.io/tags/phpstrom/"},{"name":"jetbrains","slug":"jetbrains","permalink":"https://webwlsong.github.io/tags/jetbrains/"},{"name":"nodejs","slug":"nodejs","permalink":"https://webwlsong.github.io/tags/nodejs/"},{"name":"性能测试","slug":"性能测试","permalink":"https://webwlsong.github.io/tags/性能测试/"},{"name":"delve","slug":"delve","permalink":"https://webwlsong.github.io/tags/delve/"},{"name":"mongo","slug":"mongo","permalink":"https://webwlsong.github.io/tags/mongo/"},{"name":"php-mongo","slug":"php-mongo","permalink":"https://webwlsong.github.io/tags/php-mongo/"},{"name":"swoole","slug":"swoole","permalink":"https://webwlsong.github.io/tags/swoole/"},{"name":"tcp","slug":"tcp","permalink":"https://webwlsong.github.io/tags/tcp/"},{"name":"golang","slug":"golang","permalink":"https://webwlsong.github.io/tags/golang/"},{"name":"架构","slug":"架构","permalink":"https://webwlsong.github.io/tags/架构/"}]}