{"meta":{"title":"webwlsong","subtitle":"无","description":"webwlsong的博客","author":"webwlsong","url":"https://webwlsong.github.io","root":"/"},"pages":[{"title":"关于","date":"2021-02-07T01:26:26.863Z","updated":"2020-09-09T11:54:57.430Z","comments":false,"path":"about/index.html","permalink":"https://webwlsong.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"分类","date":"2021-02-07T01:26:31.625Z","updated":"2020-09-09T11:54:57.434Z","comments":false,"path":"categories/index.html","permalink":"https://webwlsong.github.io/categories/index.html","excerpt":"","text":"Github github: username: webwlsong # github username"},{"title":"书单","date":"2020-09-09T11:54:57.431Z","updated":"2020-09-09T11:54:57.431Z","comments":false,"path":"books/index.html","permalink":"https://webwlsong.github.io/books/index.html","excerpt":"","text":"douban 豆瓣书单 douban: user: webwlsong # 豆瓣用户名 start: 0 # 从哪一条记录开始 count: 100 # 获取豆瓣书单数据条"},{"title":"404 Not Found：该页无法显示","date":"2020-09-09T11:54:57.433Z","updated":"2020-09-09T11:54:57.433Z","comments":false,"path":"/404.html","permalink":"https://webwlsong.github.io/404.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-09-09T11:54:57.432Z","updated":"2020-09-09T11:54:57.432Z","comments":true,"path":"links/index.html","permalink":"https://webwlsong.github.io/links/index.html","excerpt":"","text":"Name: link: http://example.com avatar: http://example.com/avatar.png desc: “这是一个描述”"},{"title":"Repositories","date":"2020-09-09T11:54:57.398Z","updated":"2020-09-09T11:54:57.398Z","comments":false,"path":"repository/index.html","permalink":"https://webwlsong.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-09-09T11:54:57.432Z","updated":"2020-09-09T11:54:57.432Z","comments":false,"path":"tags/index.html","permalink":"https://webwlsong.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"OpenResty安装和lua-resty-http的使用","slug":"2021/2021-02/2021-03-10","date":"2021-03-09T16:00:00.000Z","updated":"2021-03-10T09:19:13.382Z","comments":true,"path":"2021/03/10/2021/2021-02/2021-03-10/","link":"","permalink":"https://webwlsong.github.io/2021/03/10/2021/2021-02/2021-03-10/","excerpt":"","text":"安装OpenResty 加入源 1sudo yum-config-manager --add-repo https:&#x2F;&#x2F;openresty.org&#x2F;package&#x2F;centos&#x2F;openresty.repo 安装openresty 1yum install openresty 安装LuaRock luarock 是一个lua modules包安装工具 12345678$ wget https:&#x2F;&#x2F;luarocks.org&#x2F;releases&#x2F;luarocks-3.5.0.tar.gz$ tar zxpf luarocks-3.5.0.tar.gz$ cd luarocks-3.5.0$ .&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;openresty&#x2F;luajit --with-lua&#x3D;&#x2F;usr&#x2F;local&#x2F;openresty&#x2F;luajit --lua-suffix&#x3D;jit --with-lua-include&#x3D;&#x2F;usr&#x2F;local&#x2F;openresty&#x2F;luajit&#x2F;include&#x2F;luajit-2.1 &amp;&amp; make &amp;&amp; sudo make install$ sudo luarocks install luasocket$ luaLua 5.3.5 Copyright (C) 1994-2018 Lua.org, PUC-Rio&gt; require &quot;socket OpenResty中使用lua-resty-http完成HTTP请求 lua-resty-http是OpenResty版本的Http客户端，基于cosocket实现 开源地址：https://github.com/ledgetech/lua-resty-http 4.1：安装依赖 1luarocks install lua-resty-http 代码示例 GET请求： 12345678910111213local http &#x3D; require(&#39;resty.http&#39;)local httpc &#x3D; http.new()local res, err &#x3D; httpc:request_uri(&#39;http:&#x2F;&#x2F;localhost&#x2F;hello&#39;, &#123; keepalive_timeout &#x3D; 2000 -- 毫秒&#125;)if not res or res.status then ngx.log(ngx.ERR, &quot;request error#&quot;, err) returnendngx.log(ngx.ERR, &quot;request status#&quot;, res.status)ngx.say(res.body) POST请求： 12345678910111213141516171819local http &#x3D; require &quot;resty.http&quot;local httpc &#x3D; http.new()local res, err &#x3D; httpc:request_uri(&quot;http:&#x2F;&#x2F;localhost&#x2F;hello&quot;, &#123; method &#x3D; &quot;POST&quot;, body &#x3D; &quot;a&#x3D;1&amp;b&#x3D;2&quot;, headers &#x3D; &#123; [&quot;Content-Type&quot;] &#x3D; &quot;application&#x2F;x-www-form-urlencoded&quot;, &#125;, keepalive_timeout &#x3D; 60, keepalive_pool &#x3D; 10&#125;)if not res or res.status then ngx.log(ngx.ERR, &quot;request error#&quot;, err) returnendngx.log(ngx.ERR, &quot;request status#&quot;, res.status)ngx.say(res.body)","categories":[],"tags":[{"name":"OpenResty","slug":"OpenResty","permalink":"https://webwlsong.github.io/tags/OpenResty/"},{"name":"lua","slug":"lua","permalink":"https://webwlsong.github.io/tags/lua/"}]},{"title":"腾讯cdn命中率低，用户感觉cdn慢，从HTTP响应头看各家CDN缓存技术","slug":"2021/2021-02/2021-02-26","date":"2021-02-25T16:00:00.000Z","updated":"2021-02-26T08:57:27.900Z","comments":true,"path":"2021/02/26/2021/2021-02/2021-02-26/","link":"","permalink":"https://webwlsong.github.io/2021/02/26/2021/2021-02/2021-02-26/","excerpt":"","text":"腾讯云cdn命中率低是什么原因呢？ 命中率低可能由以下原因造成： 缓存配置问题，如缓存时间较短。 HTTP Header 导致无法缓存，请检查源站 Cache-Control 或 Expires 的设置。 源站类型问题，可缓存的内容少。 网站访问量低，过期时间短，命中的文件少，导致频繁回源。 文章来源：https://cloud.tencent.com/document/product/228/11207 用户感觉 CDN 访问慢？ 主要说腾讯cdn 大文件关注下载速度，小文件关注延时。首先得到用户访问慢的 URL，通过测速网站判断是否访问慢（推荐工具： 17ce ）。 如果测速确实慢，且源站属于自有源，请 提交工单 我们将协助用户排查源站机器负载和带宽是否受限。 如何判断用户访问是否命中 CDN Cache？ 查看访问回包头部的 X-Cache-Lookup 信息，若同时返回多个 X-Cache-Lookup 属正常情况，当返回 Cache Hit/Hit From MemCache/Hit From Disktank 时表示命中 CDN Cache： X-Cache-Lookup:Hit From MemCache 表示命中 CDN 节点的内存。 X-Cache-Lookup:Hit From Disktank 表示命中 CDN 节点的磁盘。 x-cache 是指从浏览器从那个地方缓存网页 x-cache-lookup项指专门查看代理服务器中是否有某个网页缓存 缓存的话，返回：hit，没有换成返回MISS 文章来源： X-Cache 和 X-Cache-Lookup headers 的解释 中文：https://blog.haohtml.com/archives/4783 英文：https://anothersysadmin.wordpress.com/2008/04/22/x-cache-and-x-cache-lookup-headers-explained/ 文章来源：https://cloud.tencent.com/document/product/228/11207 从HTTP响应头看各家CDN缓存技术 由于国内各家电信运营商互联互通的壁垒，CDN作为互联网用户加速的最后一公里，扮演了很重要的角色。 在各家公司大谈的异地多活容灾上也承担了用户分流的重任，看看各家用的东西，结合一些网上的公开资料，也能管中窥豹。 传统的国内CDN厂家有：帝联，网宿，蓝汛，快网等 新兴的互联网公司有自家产品对外输出型和创业公司细分型：BAT都有此产品，还有七牛，又拍，微软azure等 美国龙头：Akamai，美国市场大哥，Apple用的也是这个，但Apple的在线服务这么烂，真怀疑是不是Apple把Akamai带坑里了。 本文只展示响应头，有兴趣自己深挖。 ##淘宝 1234567server:Tenginestatus:200timing-allow-origin:*via:cache15.l2et15-1[0,200-0,H], cache35.l2et15-1[0,0], cache3.cn286[0,200-0,H], cache8.cn286[11,0]x-cache:HIT TCP_MEM_HIT dirn:20:727080716x-swift-cachetime:31535998x-swift-savetime:Fri, 19 Aug 2016 02:55:13 GMT 不用说，淘宝用的是自家阿里CDN， 走Tengine， 返回的响应很友好，甚至告诉你是从内存命中的。 x-swift指明了使用了的具体热点缓存技术。 关于阿里云CDN,有很多公开介绍，例如： 文章一：阿里云CDN技术演进之路 http://www.slideshare.net/jos… 文章二：研究下淘宝的swift热点缓存迁移的事 1234via:cache46.l2et2[0,200-0,H], cache60.l2et2[0,0], cache7.cn286[0,200-0,H], cache8.cn286[3,0]x-cache:HIT TCP_HIT dirn:11:60349972x-swift-cachetime:31535950x-swift-savetime:Tue, 28 Jun 2016 04:04:29 GMT 根据阿里云官网解释： 若：X-Cache:HIT TCP_MEM_HIT 表示命中缓存 若：X-Cache:MISS TCP_MISS 则表示未命中缓存 ##微信 腾讯CDN节点： 123Server:Qnginx&#x2F;1.1.1X-Cache-Lookup:Hit From DisktankX-NWS-LOG-UUID:406395d0-7cb8-4630-99cf-8208d04e7750 很明显，这里告诉大家CDN命中了磁盘缓存上的数据。 一些网上资料查到的解释： X-Cache-Lookup:Hit From MemCache 表示命中CDN节点的内存 X-Cache-Lookup:Hit From Disktank 表示命中CDN节点的磁盘 X-Cache-Lookup:Hit From Upstream 表示没有命中CDN 腾讯CDN起步可能会晚一点，Qcon上一个公开资料： CDN架构技术之道 腾讯还与小米合作，在硬盘版小米路由上推出了一个插件，叫腾讯会员兑换，本质上就是利用小米路由用户上的硬盘存储一部分内容，上传给需要用的用户，由腾讯计算收益，盘活了家里闲时的网络资源。 x-cache 是指从浏览器从那个地方缓存网页 x-cache-lookup项指专门查看代理服务器中是否有某个网页缓存 缓存的话，返回：hit，没有换成返回MISS 网易云音乐 12Server:nginxX-Via:1.1 ngdianxin90:9 (Cdn Cache Server V2.0) 网易太低调，最近也开始搞网易云产品了，但基本查不到什么公开资料，从响应头看似乎就是直接用的nginx。 新浪微博 12345678Content-Type: image&#x2F;gifSINA-LB: aGEuNDEuZzEuc2h4LmxiLnNpbmFub2RlLmNvbQ&#x3D;&#x3D;SINA-TS: ZGFkYzk4Y2UgMCAwIDAgOCAwCg&#x3D;&#x3D;Via: http&#x2F;1.1 ctc.ningbo.ha2ts4.70 (ApacheTrafficServer&#x2F;4.2.1.1 [cRs f ])X-Via-CDN: f&#x3D;Edge,s&#x3D;ctc.ningbo.ha2ts4.70,c&#x3D;115.231.82.33Age: 1X-Via: 1.1 zjjhdx33:3 (Cdn Cache Server V2.0), 1.1 tzhoudxin37:5 (Cdn Cache Server V2.0)Connection: keep-alive 这个返回了Cdn Cache Server V2.0，有多家公司都返回了这个，不知道这是个啥玩意，是不是个开源通用产品呢？Squid Varnish Nginx？ segmantfault： 命中 M.ctn-zj-lna-204123x-cache:HIT(R) from ctn-zj-lna-204x-request-id:c239b9ae8ec9f83030bbdfaabcfa8fb4x-source:U&#x2F;200, G&#x2F;200 缓存MISS 1234via:T.101195.N.1, T.101163.R.1, V.mix-hz-fdi-163, M.ctn-zj-lna-200x-cache:MISS(S) from ctn-zj-lna-200x-request-id:724565e217e01e9f60e9f1b74aecedb3在ctn-zj-lna上缓存没有命中,这个ctn-zj是个CDN集群么？ ##七牛 访问该图片:http://7xt44n.com2.z0.glb.qin… Response header返回： 1234X-Log:mc.g;IO:1&#x2F;304X-Qiniu-Zone:0X-Reqid:90oAABxCoNMaw2wUX-Via:1.1 dxxz44:2 (Cdn Cache Server V2.0), 1.1 ngdianxin42:6 (Cdn Cache Server V2.0) 用的就是自家产品。 唯品会 12345Server:vipshop&#x2F;VbibTransfer-Encoding:chunkedVip-Cache:HITx-amz-delete-marker:falseX-Via:1.1 xxxz53:0 (Cdn Cache Server V2.0), 1.1 zhdx34:6 (Cdn Cache Server V2.0) 看Server的响应头，似乎也应该是自家搭建的CDN,显示了命中与否。","categories":[],"tags":[{"name":"cdn","slug":"cdn","permalink":"https://webwlsong.github.io/tags/cdn/"},{"name":"阿里云","slug":"阿里云","permalink":"https://webwlsong.github.io/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"},{"name":"网易云","slug":"网易云","permalink":"https://webwlsong.github.io/tags/%E7%BD%91%E6%98%93%E4%BA%91/"},{"name":"七牛云","slug":"七牛云","permalink":"https://webwlsong.github.io/tags/%E4%B8%83%E7%89%9B%E4%BA%91/"},{"name":"segmantfault","slug":"segmantfault","permalink":"https://webwlsong.github.io/tags/segmantfault/"},{"name":"唯品会","slug":"唯品会","permalink":"https://webwlsong.github.io/tags/%E5%94%AF%E5%93%81%E4%BC%9A/"}]},{"title":"桌面程序技术选型大厂使用技术以及优劣对比","slug":"2021/2021-02/2021-02-06","date":"2021-02-05T16:00:00.000Z","updated":"2021-02-07T02:41:06.834Z","comments":true,"path":"2021/02/06/2021/2021-02/2021-02-06/","link":"","permalink":"https://webwlsong.github.io/2021/02/06/2021/2021-02/2021-02-06/","excerpt":"","text":"大厂客户端使用技术 软件 客户端 语言 微信/qq/百度网盘 Windows c++ duilib wps Windows c++ qt 酷狗 qq音乐 网易云音乐 阿里旺旺 Windows c++ libcef 讯雷 Windows Electron 钉钉/微小宝/微信web开发工具 Mac nw.js 钉钉 微小宝 做全端技术选型 C++ ,QT ,Winform ,Wpf,Electron,Flutter,C#(WebWindow+Blazor),Tauri Tauri 带后期观察 -话说可以取代Electron替代产品 代码仓库：https://github.com/tauri-apps/tauri Blazor 是一个使用 .NET 生成交互式客户端 Web UI 的框架： 使用 C# 代替 JavaScript 来创建信息丰富的交互式 UI。 共享使用 .NET 编写的服务器端和客户端应用逻辑。 将 UI 呈现为 HTML 和 CSS，以支持众多浏览器，其中包括移动浏览器。 与新式托管平台（如 Docker）集成。 使用 .NET 进行客户端 Web 开发可提供以下优势： 使用 C# 代替 JavaScript 来编写代码。 利用现有的 .NET 库生态系统。 在服务器和客户端之间共享应用逻辑。 受益于 .NET 的性能、可靠性和安全性。 在 Windows、Linux 和 macOS 上使用 Visual Studio 保持高效工作。 以一组稳定、功能丰富且易用的通用语言、框架和工具为基础来进行生成。 其他的自行搜索引擎查看文章 优缺点对比 NW.js 和 Electron 优缺点分析对比 通过前面的案例意识使用情况来看 优点： 开源的核心扩展比较容易，目前是基于 node 6.x，加之现在 gyp 已经非常人性化了，使得c++ 和 js 搞基非常容易。 界面定制性强，原则上只要是Web能做的他都能做。 是目前最廉价的跨平台技术方案，HTML+JS 有大量的前端技术人员储备，而且有海量的现存web UI 库。大多都很靠谱。 相对其他跨平台方案（如 QT GTK+ 等），更稳定，bug少， 毕竟只要浏览器外壳跑起来了，里面的问题不会太多 ，当然我也遇到过一些暗坑。 方便热更新。下载覆盖完事。当然这是所有脚本共有的优点。 缺点： 卡，启动慢，这可能是webkit的锅。毕竟一个浏览器要支持的功能确实有点多。 除了主进程 你可能还需要启动一些辅助进程来完成工作。而每当你新开一个进程，起步价就是一个nodejs的内存开销！ 丢帧，这个最严重，可我已习惯了native 的丝滑. mac下感觉还可以 win下有点够呛。 打出来的包太大。（很显然，即便是一个空包，也至少包含了一个浏览器的体积 根据2021年1月语言排行榜 我的技术选型 如果2021年开始做全端的互联网产品，目前阶段我的个人优先选择Flutter &gt; Electron C#(WebWindow+Blazor)后劲十足，后期观察tauri根据作者的排的计划来看，估计要到2021年底才出一个bete版本，官网 2022年以后才能做一个稳定版本 根据不同产品需求技术选型时不一样，仁者见仁，智者见智。如果：如果做汽车类的一些产品或者工业级级别客户端优先去考虑QT,毕竟库还是很丰富。 我的技术选型一般从一下几个方面去考虑： 技术生命周期，活跃性 在某些行业库是否比较丰富 根据团队的技术特点和项目的时间规划周期 参考资料 nw.js和Electron 优劣对比 https://blog.csdn.net/small_tu/article/details/86606819 https://www.jianshu.com/p/7c66ee28ce51 Asp.net Core Blazor https://www.jianshu.com/p/7c66ee28ce51 https://docs.microsoft.com/zh-cn/aspnet/core/blazor/?view=aspnetcore-5.0","categories":[],"tags":[{"name":"Electron","slug":"Electron","permalink":"https://webwlsong.github.io/tags/Electron/"},{"name":"C++","slug":"C","permalink":"https://webwlsong.github.io/tags/C/"},{"name":"QT","slug":"QT","permalink":"https://webwlsong.github.io/tags/QT/"},{"name":"Flutter","slug":"Flutter","permalink":"https://webwlsong.github.io/tags/Flutter/"}]},{"title":"php Maximum execution time of 0 seconds exceeded","slug":"2021/2021-02/2021-02-03","date":"2021-02-02T16:00:00.000Z","updated":"2021-02-07T02:29:44.171Z","comments":true,"path":"2021/02/03/2021/2021-02/2021-02-03/","link":"","permalink":"https://webwlsong.github.io/2021/02/03/2021/2021-02/2021-02-03/","excerpt":"","text":"#0 [1]ErrorException in PDOConnection.php line 1240 Maximum execution time of 0 seconds exceeded 12345678910 ; Maximum amount of time each script may spend parsing request data. It&#x27;s a good ; idea to limit this time on productions servers in order to eliminate unex pectedly; long running scripts.; Note: This directive is hardcoded to -1 for the CLI SAPI; Default Value: -1 (Unlimited); Development Value: 60 (60 seconds); Production Value: 60 (60 seconds); http://php.net/max-input-time ;默认是60 每个页面接受数据最大的时间 max_input_time = 60 这种情况可能用两种情况下产生： 内存超限制，可以通过在循环里面添加sleep(5),放置同时间内存占满的，每个循环内部使用ob_frush 释放内存 页面请求时间超时 修改请求数据超时max_input_time 设置大些 解决：PHP脚本执行超时 max_execution_time = 600 //最大执行时间 max_input_time = 600 //页面请求接受数据最大时间 memory_limit= 128M //脚本内存限制","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://webwlsong.github.io/tags/PHP/"},{"name":"超时","slug":"超时","permalink":"https://webwlsong.github.io/tags/%E8%B6%85%E6%97%B6/"}]},{"title":"图解微信第三方开放平台流程图","slug":"2020/2020-09/2020-09-24","date":"2020-09-23T16:00:00.000Z","updated":"2020-09-23T16:29:55.964Z","comments":true,"path":"2020/09/24/2020/2020-09/2020-09-24/","link":"","permalink":"https://webwlsong.github.io/2020/09/24/2020/2020-09/2020-09-24/","excerpt":"","text":"微信第三方开放平台流程图 授权流程技术说明 小程序或者公众号授权给第三方平台的技术实现流程比较简单，如下图所示： 第三方服务商构建授权链接放置自己的网站，用户点击后，弹出授权页面 账号管理员扫码，选择需要授权的账号，进行授权。 用户可自定义选择权限集进行授权 下面对其进行详细介绍： 步骤 1：第三方平台方获取预授权码（pre_auth_code） 详见 步骤 2：引入用户进入授权页 第三方平台方可以在自己的网站中放置“微信公众号授权”或者“小程序授权”的入口，或生成授权链接放置在移动网页中，引导公众号和小程序管理员进入授权页。 方式一：授权注册页面扫码授权 授权页网址为： https://mp.weixin.qq.com/cgi-bin/componentloginpage?component_appid=xxxx&amp;pre_auth_code=xxxxx&amp;redirect_uri=xxxx&amp;auth_type=xxx。 参考文献: 微信第三方平台授权流程技术说明 https://developers.weixin.qq.com/doc/oplatform/Third-party_Platforms/Third_party_platform_appid.html","categories":[{"name":"小程序","slug":"小程序","permalink":"https://webwlsong.github.io/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"https://webwlsong.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"pyenv的安装和简单使用（git、pyenv、pyenv-virtualenv）","slug":"2020/2020-09/2020-09-18","date":"2020-09-17T16:00:00.000Z","updated":"2020-09-18T01:05:00.102Z","comments":true,"path":"2020/09/18/2020/2020-09/2020-09-18/","link":"","permalink":"https://webwlsong.github.io/2020/09/18/2020/2020-09/2020-09-18/","excerpt":"","text":"[TOC] Python工作环境管理 Python 2和Python 3之间存在着较大的差异，并且，由于各种原因导致了Python 2和Python 3的长期 共存。在实际工作过程中，我们可能会同时用到Python 2和Python 3，因此，需要经常在Python 2和 Python 3之间进行来回切换。此外，如果你是喜欢尝鲜的人，那么，你很有可能在Python新版本出来 的时候立即下载Python的版本，试验Python的特性。 在Python世界里，除了需要对Python的版本进行管理以外，还需要对不同的软件包进行管理。大部分 情况下，对于开源的库我们使用版本即可。但是，有时候可能需要对相同的Python版本，在不同的 项目中使用不同版本的软件包。 在这一节里，我们将介绍两个工具，即pyenv和virtualenv。前者用于管理不同的Python版本，后者用 于管理不同的工作环境。有了这两个工具，Python相关的版本问题将不再是问题。 1、情景问题 Python解释器版本混乱, 2和3差别巨大, 而且细分版本也不尽相同, 难以选择和管理. 不同Linux发行版自带Python不同, 如ubuntu16自带2.7和3.5版本, 其中系统许多组件依赖于自带解释器, 一旦删除或者更改都可能会造成系统出问题. 不同的Python解释器软件包管理也是问题, 如pip和ipython等必备包组件, 而且在项目开发中如何保证不同的包环境互不干扰也是一个问题. 那么有没有一个终极的解决办法能在管理不同解释器版本的同时控制不同的包环境呢? 有的, 就是pyenv. 2、使用pyenv管理不同的Python版本 安装不同的Python版本并不是一件容易的事情，在不同的Python版本之间来回切换更加困难，而且， 多版本并存非常容易互相干扰。因此，我们需要一个名为pyenv的工具。pyenv是一个Python版本管理 工具，它能够进行全局的Python版本切换，也可以为单个项目提供对应的Python版本。使用pyenv以 后，可以在服务器上安装多个不同的Python版本，也可以安装不同的Python实现。不同Python版本之 间的切换也非常简单。接下来我们就一起看一下pyenv的安装和使用。 pyenv是什么? 能干什么? 123456pyenv是一个forked自ruby社区的简单、低调、遵循UNIX哲学的Python环境管理工具, 它可以轻松切换全局解释器版本, 同时结合vitualenv插件可以方便的管理对应的包源. 我们知道, 在terminal中输入一个命令比如‘ls’时, shell会从当前环境的PATH中的各个目录里看是不是有ls这个可执行文件, 如果找到就执行, 否则就会报‘command no found’ 的错误, 同理, 只要控制PATH变量就能够做到python版本的切换, pyenv通过在PATH头部插入shims路径来实现对python版本的控制. pyenv和流行的pipenv、virtualenv的关系 pipenv是requests 作者 Kenneth Reitz大神写的一个python虚拟环境管理工具, 结合了pip和virtualenv的功能, 侧重点还是在包环境管理上, 使用思路是先创建一个指定python版本的环境, 然后在此环境上安装相应的包, 好评不错, 看到很多大牛都在推荐. pipenv是requests 作者 Kenneth Reitz大神写的一个python虚拟环境管理工具, 结合了pip和virtualenv的功能, 侧重点还是在包环境管理上, 使用思路是先创建一个指定python版本的环境, 然后在此环境上安装相应的包, 好评不错, 看到很多大牛都在推荐. pyenv相对来说知名度就差很多了, 不过也很稳定, 这三个环境管理工具我都用过, 我个人更喜欢pyenv, 理由如下: 相对于其他两个工具, pyenv更侧重在python 解释器版本管理上, 比包管理更大一个层级, 使用pyenv我可以方便的下载指定版本的python解释器, pypy, anaconda等, 可以随时自由的在shell环境中本地、全局切换python解释器 开发的时候不需要限定某个版本的虚拟环境, 只需要在部署的时候用pyenv指定某个版本就好了 pyenv切换解释器版本的时候, pip和ipython以及对应的包环境都是一起切换的, 所以如果你要同时运行ipython2.x和ipython3.x多个解释器验证一些代码时就很方便 pyenv也可以创建好指定的虚拟环境, 但不需要指定具体目录, 自由度更高, 使用也简单 4、简单使用 123456789101112131415161718192021222324# 查看当前版本pyenv version# 查看所有版本pyenv versions# 查看所有可安装的版本pyenv install --list# 安装指定版本pyenv install 3.6.5# 安装新版本后rehash一下pyenv rehash# 删除指定版本pyenv uninstall 3.5.2# 指定全局版本pyenv global 3.6.5# 指定多个全局版本, 3版本优先pyenv global 3.6.5 2.7.14# 实际上当你切换版本后, 相应的pip和包仓库都是会自动切换过去的 一、pyenv安装 安装 pyenv 说明：本文的所有安装都严格遵守官方文档，与官方文档完全保持一致。 git 地址：https://github.com/pyenv/pyenv 在你的终端中执行如下命令，安全无毒，请放心食用： 首先把项目克隆下来，放在家目录下的隐藏文件夹中：.pyenv 1git clone https:&#x2F;&#x2F;github.com&#x2F;pyenv&#x2F;pyenv.git ~&#x2F;.pyenv 然后配置变量 如果你使用 bash，就依次执行如下命令： 1234echo &#x27;export PYENV_ROOT=&quot;$HOME/.pyenv&quot;&#x27; &gt;&gt; ~/.bashrcecho &#x27;export PATH=&quot;$PYENV_ROOT/bin:$PATH&quot;&#x27; &gt;&gt; ~/.bashrcecho -e &#x27;if command -v pyenv 1&gt;/dev/null 2&gt;&amp;1; then\\n eval &quot;$(pyenv init -)&quot;\\nfi&#x27; &gt;&gt; ~/.bashrc 如果你使用 zsh，就依次执行如下命令： 123echo &#x27;export PYENV_ROOT=&quot;$HOME/.pyenv&quot;&#x27; &gt;&gt; ~/.zshrcecho &#x27;export PATH=&quot;$PYENV_ROOT/bin:$PATH&quot;&#x27; &gt;&gt; ~/.zshrcecho -e &#x27;if command -v pyenv 1&gt;/dev/null 2&gt;&amp;1; then\\n eval &quot;$(pyenv init -)&quot;\\nfi&#x27; &gt;&gt; ~/.zshrc echo 命令的含义是：将引号中内容写入某文件中 请注意，以上的三条 echo 命令的最后一条长长的命令，请你保证它引号中的内容处于 ~/.bashrc 或者 ~/.zshrc 的最底部。 因为在 pyenv 初始化期间会操作 path 环境变量，导致不可预测的行为。 查看文件的底部内容，可以使用 tail 命令，用法：tail ~/.bashrc 或者 tail ~/.zshrc，编辑文件可以使用 vim 或者 vscode 最后，在使用 pyenv 之前，重新初始化 shell 环境，执行如下命令 1exec $SHELL 或者 source 不执行该命令也是完全可以的，你可以关闭当前的终端窗口，重新启动一个就可以了。 此时，你已经完成了 pyenv 的安装了，你使用可以它的全部命令了，但是我建议你先别急着用，一口气装完 pyenv 的一个插件，那就是 pyenv-virtualenv 安装 pyenv-virtualenv virtualenv本身是一个独立的项目，用以隔离不同项目的工作环境。例如，用户lmx希望在项目A中使用 Flask 0.8这个版本，与此同时，又想在项目B中使用Flask 0.9这个版本。如果我们全局安装Flask，必然 无法满足用户的需求。这个时候，我们就可以使用virtualenv。 读者需要注意pyenv和virtualenv的区别。pyenv用以管理不同的Python版本，例如，你的系统工作时 使用Python 2.7.13，学习时使用Python 3.6.0。virtualenv用以隔离项目的工作环境，例如，项目A和 项目B都是使用Python 2.7.13，但是，项目A需要使用Flask 0.8版本，项目B需要使用Flask 0.9版本。我 们只要组合pyenv和virtualenv这两个工具，就能够构造Python和第三方库的任意版本组合，拥有很好 的灵活性，也避免了项目之间的相互干扰。 virtualenv本身是一个独立的工具，用户可以不使用pyenv而单独使用virtualenv。但是，如果你使用了 pyenv，就需要安装pyenv-virtualenv插件，而不是通过virtualenv软件使用virtualenv的功能。 git 地址：https://github.com/pyenv/pyenv-virtualenv (1) 把插件克隆在刚才已经安装完毕的 pyenv 的 plugins 文件夹中 1git clone https://github.com/pyenv/pyenv-virtualenv.git $(pyenv root)/plugins/pyenv-virtualenv (2) 然后配置环境变量 如果你使用 bash，就执行如下命令： 1echo &#x27;eval &quot;$(pyenv virtualenv-init -)&quot;&#x27; &gt;&gt; ~/.bashrc 如果你使用 zsh，就执行如下命令： 1echo &#x27;eval &quot;$(pyenv virtualenv-init -)&quot;&#x27; &gt;&gt; ~/.zshrc (3) 最后，在使用 pyenv 之前，重新初始化 shell 环境，执行如下命令 1exec $SHELL 不执行该命令也是完全可以的，你可以关闭当前的终端窗口，重新启动一个就可以了。 至此，pyenv就安装完成了，我们可以通过下面的命令验证pyenv是否正确安装并获取pyenv的帮助信息： 123456789101112131415161718192021222324252627282930313233343536pyenv --helpUsage: pyenv &lt;command&gt; [&lt;args&gt;]Some useful pyenv commands are: --version Display the version of pyenv activate Activate virtual environment commands List all available pyenv commands deactivate Deactivate virtual environment exec Run an executable with the selected Python version global Set or show the global Python version(s) help Display help for a command hooks List hook scripts for a given pyenv command init Configure the shell environment for pyenv install Install a Python version using python-build local Set or show the local application-specific Python version(s) prefix Display prefix for a Python version rehash Rehash pyenv shims (run this after installing executables) root Display the root directory where versions and shims are kept shell Set or show the shell-specific Python version shims List existing pyenv shims uninstall Uninstall a specific Python version version Show the current Python version(s) and its origin version-file Detect the file that sets the current pyenv version version-name Show the current Python version version-origin Explain how the current Python version is set versions List all Python versions available to pyenv virtualenv Create a Python virtualenv using the pyenv-virtualenv plugin virtualenv-delete Uninstall a specific Python virtualenv virtualenv-init Configure the shell environment for pyenv-virtualenv virtualenv-prefix Display real_prefix for a Python virtualenv version virtualenvs List all Python virtualenvs found in `$PYENV_ROOT/versions/*&#x27;. whence List all Python versions that contain the given executable which Display the full path to an executableSee `pyenv help &lt;command&gt;&#x27; for information on a specific command.For full documentation, see: https://github.com/pyenv/pyenv#readme 二、使用 pyenv 此处仅仅展示 pyenv 和 virtualenv 的日常用法 1、检查安装是否正确 检查 pyenv 的版本 12345[root@python ~]# pyenv version(set by /root/.pyenv/version)查看 pyenv 已经管理了哪些 python 版本[root@python ~]#pyenv versions* system (set by /root/.pyenv/version) 如果你看到了正常的版本信息，就说明可以了，如果看到了类似于 command not found 之类的，就说明安装失败了。 我们通过pyenv的install命令，可以查看pyenv当前支持哪些Python版本，如下所示： 123456789101112131415[root@python ~]# pyenv install --list Available versions:2.1.3……省略部分信息3.8.03.8-dev3.8.13.9-dev……省略部分信息anaconda3-2018.12anaconda3-2019.03anaconda3-2019.07anaconda3-2019.10……省略部分信息[root@python ~]# 2、pyenv切换python版本 由于pyenv可以安装的Python版本列表非常长，所以，这里进行了省略。读者可以在自己电脑上安装 pyenv，然后执行pyenv install --list命令进行查看。可以看到，pyenv不但可以安装不同的Python版 本，而且还可以安装不同的Python实现，也可以安装版本的Python用以学习。 查看当前系统中包含的Python版本： 12345[root@python ~]# pyenv versions * system (set by /root/.pyenv/version)使用pyenv安装不同的Python版本：[root@python ~]#pyenv install -v 3.8.1 [root@python ~]#pyenv install -v 2.7.13 再次查看当前系统中包含的Python版本 1234[root@python ~]# pyenv versions* system (set by /root/.pyenv/version) 2.7.13 3.8.1 切换前为3.8.1 12345#切换当前为3.8.1[root@python ~]# pythonPython 3.8.1 (default, Apr 20 2020, 15:00:10) [GCC 4.8.5 20150623 (Red Hat 4.8.5-39)] on linuxType &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more informatio 切换为2.7.13 12345[root@python ~]# pyenv global 2.7.13 [root@python ~]# pythonPython 2.7.13 (default, Apr 20 2020, 15:04:15) [GCC 4.8.5 20150623 (Red Hat 4.8.5-39)] on linux2Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information. 使用pyenv以后，可以快速切换Python的版本。切换Python版本以后，与版本相关的依赖也会一起切 换。因此，我们不用担心不同的版本在系统中是否会相互干扰。例如，切换Python版本以后，相应的 pip也会跟着切换，所以不用担心自己使用的pip版本和Python版本不匹配的问题，如下所示： 12345[root@python ~]# pyenv global 3.8.1[root@python ~]# pip --versionpip 19.2.3 from /root/.pyenv/versions/3.8.1/lib/python3.8/site-packages/pip (python 3.8)如果想要删除Python版本，使用uninstall命令即可。如下所示：[root@python ~]# pyenv uninstall 2.7.10 三、pyenv-virtualenv的使用 有了pyenv-virtualenv以后，我们可以为同一个Python解释器，创建多个不同的工作环境。例如，我们 新建两个工作环境： 12345678[root@python ~]# pyenv virtualenv 3.8.1 first_project [root@python ~]# pyenv virtualenv 3.8.1 second_projec可以使用virtualenvs子命令查看工作环境[root@python ~]# pyenv virtualenvs 3.8.1/envs/first_project (created from /root/.pyenv/versions/3.8.1) 3.8.1/envs/second_projec (created from /root/.pyenv/versions/3.8.1) first_project (created from /root/.pyenv/versions/3.8.1) second_projec (created from /root/.pyenv/versions/3.8.1) 创建完工作环境以后，可以通过activate和deactivate子命令进入或退出一个工作环境。进入工作环境 以后，左边的提示符会显示你当前所在的工作环境，以免因为环境太多导致操作错误。 12345678910111213141516171819(first_project) [root@python ~]# pip install flask==1.1.1 Looking in indexes: https://pypi.doubanio.com/simpleCollecting flask==1.1.1 Downloading https://pypi.doubanio.com/packages/9b/93/628509b8d5dc749656a9641f4caf13540e2cdec85276964ff8f43bbb1d3b/Flask-1.1.1-py2.py3-none-any.whl (94kB) |███▌ | 10kB 28.0MB/s eta 0:00: |███████ | 20kB 1.8MB/s eta 0:00:0 |██████████▍ | 30kB 2.7MB/s eta 0:00:0 |█████████████▉ | 40kB 1.8MB/s eta 0:00:0 |█████████████████▍ | 51kB 1.3MB/s eta 0:00:0 |████████████████████▉ | 61kB 1.5MB/s eta 0:00:0 |████████████████████████▎ | 71kB 1.4MB/s eta 0:00:0 |███████████████████████████▊ | 81kB 1.3MB/s eta 0:00:0 |███████████████████████████████▏| 92kB 1.4MB/s eta 0:00:0 |████████████████████████████████| 102kB 1.6MB/s Collecting itsdangerous&gt;=0.24 (from flask==1.1.1)(first_project) [root@python ~]# pyenv deactivate## 退出first_project环境[root@python ~]# 接下来，我们看一下在不同的工作环境安装不同的Flask版本 123456789101112131415[root@python ~]# pyenv activate first_project ##切换工作环境(first_project) [root@python ~]# pip install flask==1.1.1 ##安装1.1.1的flask(first_project) [root@python ~]# pyenv deactivate ##退出目前工作环境[root@python ~]#[root@python ~]# pyenv activate second_projec##切换工作环境(second_project) [root@python ~]# pip install flask==0.10.1##安装0.10.1的flask(second_project) [root@python ~]# pyenv deactivate ##退出目前工作环境[root@python ~]# 查看一下两个工作环境源目录 pyenv的安装和简单使用（git、pyenv、pyenv-virtualenv） 如果想要删除虚拟环境，则使用： 12(first_project) [root@python ~]# pyenv virtualenv-delete first_project 使用pyenv和python-virtualenv插件，我们就能够自由地在不同的版本之间进行切换，相比管理Python 版本，不但节省了时间，也避免了工作过程中的相互干扰。 四、更新 pyenv 由于我们是 git 克隆的，所以更新非常简单 12cd ~/.pyenv` 或者 `cd $(pyenv root)` `git pull 五、卸载 pyenv 由于 pyenv 把一切都放在 ~/.pyenv 下了，所以卸载很方便，两个步骤就行了 首先你需要删除环境变量 然后你需要执行： 1rm -rf ~/.pyenv` 或者 `rm -rf $(pyenv root) 载录文献: pyenv的安装和简单使用（git、pyenv、pyenv-virtualenv） https://blog.51cto.com/14320361/2488888","categories":[{"name":"python","slug":"python","permalink":"https://webwlsong.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://webwlsong.github.io/tags/python/"},{"name":"pyenv","slug":"pyenv","permalink":"https://webwlsong.github.io/tags/pyenv/"}]},{"title":"Mac用串口(ttl)连接树莓派3b+以及串口调试","slug":"2020/2020-09/2020-09-07","date":"2020-09-06T16:00:00.000Z","updated":"2021-02-07T02:06:57.298Z","comments":true,"path":"2020/09/07/2020/2020-09/2020-09-07/","link":"","permalink":"https://webwlsong.github.io/2020/09/07/2020/2020-09/2020-09-07/","excerpt":"","text":"MacOSX用串口(TTL)连接树莓派 树莓派在没有显示使用时，可以使用usb串口转ttl进行连接。 USB转ttl线 CP2102下载对应的驱动 USB转TTL 驱动下载地址：http://pan.baidu.com/s/1mgCFd9m 安装完成后重启系统，插入 USB to TTL 线可查询串口设备。 12$ ls /dev/tty.usbserial* #在Mac是这个，去查看。插拔usb能够看到对应的设备/dev/tty.usbserial USB转TTL线 树莓派3b+引脚图 USB to TTL 线与树莓派针脚对应关系为： GND -&gt; GND RXD -&gt; GPIO 14(TXD) TXD -&gt; GPIO 15(RXD) VCC -&gt; 悬空 (切记, 不要乱接) 注意: 一定按照上面的对应关系，不要接成一样的。 配置minicom参数 运行 1sudo minicom -s 进入minicom界面 123456789101112┌─────[configuration]──────┐│ Filenames and paths ││ File transfer protocols ││ Serial port setup ││ Modem and dialing ││ Screen and keyboard ││ Save setup as dfl ││ Save setup as.. ││ Exit ││ Exit from Minicom │└──────────────────────────┘ 使用上下键选择Serial port setup，回车。此时停留在change which setting? 通过A,B,C,D选项设置对应的参数设置例如下 123456789101112┌───────────────────────────────────────────────────────────────────────┐│ A - Serial Device : /dev/modem ││ B - Lockfile Location : /usr/local/Cellar/minicom/2.7.1/var ││ C - Callin Program : ││ D - Callout Program : ││ E - Bps/Par/Bits : 115200 8N1 ││ F - Hardware Flow Control : Yes ││ G - Software Flow Control : No ││ ││ Change which setting? │└───────────────────────────────────────────────────────────────────────┘ 配置选项目录 选择&quot;Filenames and paths&quot; 1234567891011┌───────────────────────────────────────────────────────────────────────┐│ A - Download directory : /home/wonux ││ B - Upload directory : /tmp ││ C - Script directory : /root/minicom ││ D - Script program : runscript or /bin/bash ││ E - Kermit program : ││ F - Logging options ││ ││ Change which setting? │└───────────────────────────────────────────────────────────────────────┘ 常用配置总结： 选择Serial port setup 配置选项如下： 1234A - Serial Device : /dev/modem E - Bps/Par/Bits : 115200 8N1 F - Hardware Flow Control : No G - Software Flow Control : No 选择Filenames and paths 配置其中的如下配置项： 12C - Script directory : /root/minicomD - Script program : /bin/bash C:脚本文件的存放位置: g运行脚本时的路径 。 D:选择脚本程序: 默认runscript,也可以选择bash脚本格式。 树莓派3b+添加散热外壳 在某宝上买了一个外壳。 线与树莓派针脚对应关系为： 红色-&gt; +5v 黑色-&gt; GND #地线 mac串口调试工具minicom 我们使用常用的串口工具，如：minicom, screen 使用 115200 进行连接。它们的安装也非常的方便： 123456789# 安装 minicom$ brew install minicom# 进行配置后再进行连接$ minicom -s# 安装 screen$ brew install screen# 进行连接screen /dev/tty.usbserial 115200 连接后我们输入默认的账号和密码 12用户名：pi密码：raspberry 树莓派连接上网设置 12345678910111213141516171819202122ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdevupdate_config=1country=GBnetwork=&#123; ssid=&quot;######&quot; #wifi 名称 psk=&quot;*******&quot; #wifi密码 proto=RSN key_mgmt=WPA-PSK #加密方式 pairwise=CCMP auth_alg=OPEN&#125;network=&#123; ssid=&quot;#######&quot; psk=&quot;**********&quot; proto=RSN key_mgmt=WPA-PSK pairwise=CCMP auth_alg=OPEN&#125;~ 完整呈现： 参考资料： https://blog.csdn.net/sikinzen/article/details/5451758 minicom中文手册 https://www.jianshu.com/p/71191dd41eab https://www.jianshu.com/p/40412eb7f567 https://www.jianshu.com/p/b132508a0fa3?from=singlemessage","categories":[],"tags":[{"name":"树莓派","slug":"树莓派","permalink":"https://webwlsong.github.io/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"}]},{"title":"图解Golang的内存管理分配","slug":"2020/2020-09/2020-09-02","date":"2020-09-02T16:00:00.000Z","updated":"2020-09-18T01:05:32.948Z","comments":true,"path":"2020/09/03/2020/2020-09/2020-09-02/","link":"","permalink":"https://webwlsong.github.io/2020/09/03/2020/2020-09/2020-09-02/","excerpt":"","text":"go主要有以下五种内存存储区(c/c++也是一样)： Go的内存分配核心思想 Go是内置运行时的编程语言(runtime)，像这种内置运行时的编程语言通常会抛弃传统的内存分配方式，改为自己管理。这样可以完成类似预分配、内存池等操作，以避开系统调用带来的性能问题，防止每次分配内存都需要系统调用。 用户线程的调度以及生命周期管理都是用户层面，Go语言自己实现的，不借助OS系统调用，减少系统资源消耗。 Go的内存分配的核心思想可以分为以下几点： 每次从操作系统申请一大块儿的内存，由Go来对这块儿内存做分配，减少系统调用 内存分配算法采用Google的TCMalloc算法。算法比较复杂，究其原理可自行查阅。其核心思想就是把内存切分的非常的细小，分为多级管理，以降低锁的粒度。 回收对象内存时，并没有将其真正释放掉，只是放回预先分配的大块内存中，以便复用。只有内存闲置过多的时候，才会尝试归还部分内存给操作系统，降低整体开销 业界比较出名的内存分配器有Google的tcmalloc和Facebook的jemalloc。二者在避免内存碎片和性能上均比glic有比较大的优势，在多线程环境中效果更明显。 程序在内存中的分布 代码段(.text)，也称文本段(Text Segment)，存放着程序的机器码和只读数据，可执行指令就是从这里取得的。如果可能，系统会安排好相同程序的多个运行实体共享这些实例代码。这个段在内存中一般被标记为只读，任何对该区的写操作都会导致段错误（Segmentation Fault） 数据段，包括已初始化的数据段(.data)和未初始化的数据段（.bss），前者用来存放保存全局的和静态的已初始化变量，后者用来保存全局的和静态的未初始化变量。数据段在编译时分配 堆栈段分为堆和栈： 堆（Heap）：用来存储程序运行时分配的变量。堆的大小并不固定，可动态扩张或缩减。其分配由malloc()、new()等这类实时内存分配函数来实现。当进程调用malloc等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用free 等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减） 堆的内存释放由应用程序去控制，通常一个new()就要对应一个delete()，如果程序员没有释放掉，那么在程序结束后操作系统会自动回收。 栈（Stack）是一种用来存储函数调用时的临时信息的结构，如函数调用所传递的参数、函数的返回地址、函数的局部变量等。 在程序运行时由编译器在需要的时候分配，在不需要的时候自动清除。 栈的特性: 最后一个放入栈中的物体总是被最先拿出来，这个特性通常称为先进后出(FILO)队列。` 栈的基本操作： PUSH操作：向栈中添加数据，称为压栈，数据将放置在栈顶； POP操作：POP操作相反，在栈顶部移去一个元素，并将栈的大小减一，称为弹栈。 堆和栈的区别 分配和管理方式不同 ： 堆是动态分配的，其空间的分配和释放都由程序员控制。 栈由编译器自动管理。栈有两种分配方式：静态分配和动态分配。 静态分配由编译器完成，比如局部变量的分配。 动态分配由alloca()函数进行分配，但是栈的动态分配和堆是不同的，它的动态分配是由编译器进行释放，无须手工控制。 产生碎片不同 对堆来说，频繁的new/delete或者malloc/free势必会造成内存空间的不连续，造成大量的碎片，使程序效率降低。 对栈而言，则不存在碎片问题，因为栈是先进后出的队列，永远不可能有一个内存块从栈中间弹出。 生长方向不同 堆是向着内存地址增加的方向增长的，从内存的低地址向高地址方向增长。 栈的生长方向与之相反，是向着内存地址减小的方向增长，由内存的高地址向低地址方向增长。 了解更多： 图解TCMalloc goole内存分配器 C/C++程序的5种内存存储区及示意 参考文献: 程序在内存中的分布 https://www.cnblogs.com/Lynn-Zhang/p/5449199.html 从内存分配开始 https://mp.weixin.qq.com/s/EyWKFRu1xryoHY386QUcuA 译文：Go 内存分配器可视化指南 https://www.linuxzen.com/go-memory-allocator-visual-guide.html 图解Go语言内存分配 https://juejin.im/post/5c888a79e51d456ed11955a8 Golang源码探索(三) GC的实现原理 https://www.cnblogs.com/zkweb/p/7880099.html 《Go专家编程》Go 内存管理 https://my.oschina.net/renhc/blog/2236782?spm=a2c4e.10696291.0.0.a8e219a4hLvsZx 雨痕&lt;&lt;Go源码解析&gt;&gt; go内存分配(英文) https://andrestc.com/post/go-memory-allocation-pt1/","categories":[{"name":"go","slug":"go","permalink":"https://webwlsong.github.io/categories/go/"},{"name":"内存","slug":"go/内存","permalink":"https://webwlsong.github.io/categories/go/%E5%86%85%E5%AD%98/"},{"name":"堆栈","slug":"go/内存/堆栈","permalink":"https://webwlsong.github.io/categories/go/%E5%86%85%E5%AD%98/%E5%A0%86%E6%A0%88/"}],"tags":[{"name":"go","slug":"go","permalink":"https://webwlsong.github.io/tags/go/"},{"name":"c","slug":"c","permalink":"https://webwlsong.github.io/tags/c/"},{"name":"c++","slug":"c","permalink":"https://webwlsong.github.io/tags/c/"},{"name":"内存","slug":"内存","permalink":"https://webwlsong.github.io/tags/%E5%86%85%E5%AD%98/"},{"name":"堆栈","slug":"堆栈","permalink":"https://webwlsong.github.io/tags/%E5%A0%86%E6%A0%88/"}]},{"title":"DIY服务器搭建，内网穿透搭建","slug":"2020/2020-08/2020-08-31","date":"2020-08-31T09:09:00.000Z","updated":"2020-09-09T11:54:57.405Z","comments":true,"path":"2020/08/31/2020/2020-08/2020-08-31/","link":"","permalink":"https://webwlsong.github.io/2020/08/31/2020/2020-08/2020-08-31/","excerpt":"","text":"起初一直在用云服务器来搭自用服务器，为什么还要用自建一个服务器？ 云服务价格偏高性 性能达不到要求 IT人爱折腾，生命不止，学习不止 服务器选择 耗电量小 性价比高 噪声小(几乎没有噪声) 考虑过台式工作站服务器，NAS，最终选择mini电脑当自用服务器。 制作U盘Linux启动盘 推荐使用工具rufus(推荐),UltraISO(不太推荐) rufus做好启动盘之后，不需要修改卷标 UltraIOS启动盘 U盘启动电脑进入安装界面 12vmlinuz initrd&#x3D;initrd.img inst.stage2&#x3D;hd:LABEL&#x3D;CentOS\\x207\\x20x86_64 rd.live.check quiet #这是按 Tab 键后的默认值； rufus 启动 通常ubuntu桌面和显卡驱动不兼容，导致安装完整之后进入不到桌面 解决方法： 1:更换桌面管理器 2:进入tty 按ctrl+alt+f2 12sudo apt install lightdmsudo service lightdm restart 默认启动多用户启动 12sudo systemctl set-default multi-user.target#然后输入reboot命令重启： 单次启动图形界面: 12sudo systemctl start graphical.targetswitchdesk GNOME&quot;,回车，再输入&quot;startx 默认启动为图形界面: 12systemctl set-default graphical.target#然后执行reboot命令重启系统即可。 设置无线上网，Ubuntu20.04.1是这个目录 12345678910vim &#x2F;etc&#x2F;netplan&#x2F;01-network-manager-all.yaml#添加 ethernets: wlp1s0: #配置的网卡的名称 dhcp4: no #关闭DHCP，如果需要打开DHCP则写yes dhcp6: no addresses: [192.168.1.10&#x2F;24] #配置的静态ip地址和掩码 gateway4: 192.168.1.1 #网关地址 nameservers: addresses: [192.168.1.1,114.114.114.114] #DNS服务器地址，多个DNS服务器地址需要用英文逗号分隔开 使其ip生效 1sudo netplan apply 现在查看一下 IP是否生效 1ip addr 或者 ifconfig frp内网穿透 设备清单： 一台云主机 一台家用服务器 frp 官方地址：https://github.com/fatedier/frp/ frp 中文文档：https://github.com/fatedier/frp/blob/dev/README_zh.md 我这里使用的是第三方，frpMgr极速安装包： https://github.com/Zo3i/frpMgr 在云主机里面安装 12wget -O - https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;Zo3i&#x2F;OCS&#x2F;master&#x2F;docker&#x2F;docker-all2.sh | shwget -O - https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;Zo3i&#x2F;frpMgr&#x2F;master&#x2F;web&#x2F;src&#x2F;main&#x2F;docker&#x2F;final&#x2F;run.sh | sh 安装完成登陆： 注：代码仅在Centos7,Debian9系统上通过测试 访问:你的服务器 ip:8999/frp 账号 admin 密码 12345678 查看日志命令： 121. docker ps2. docker logs -f --tail 10 java项目的容器I 如果需要修改代码,请自行编译 jar包重新部署即可… 详细FRP快捷配置面板 https://github.com/Zo3i/frpMgr/blob/master/README_zh.md 启动，停止，重启frps服务 123service frps statusservice frps stopservice frps restart","categories":[],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"https://webwlsong.github.io/tags/ubuntu/"},{"name":"linux","slug":"linux","permalink":"https://webwlsong.github.io/tags/linux/"},{"name":"frp","slug":"frp","permalink":"https://webwlsong.github.io/tags/frp/"},{"name":"内网穿透","slug":"内网穿透","permalink":"https://webwlsong.github.io/tags/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"}]},{"title":"Ubuntu20.04.1关闭图形界面，使用tty登陆","slug":"2020/2020-08/2020-08-30-1","date":"2020-08-30T03:08:00.000Z","updated":"2020-09-09T11:54:57.405Z","comments":true,"path":"2020/08/30/2020/2020-08/2020-08-30-1/","link":"","permalink":"https://webwlsong.github.io/2020/08/30/2020/2020-08/2020-08-30-1/","excerpt":"","text":"Ubuntu 关闭图形界面，使用tty登陆 tty是终端设备的统称，TeleTYpe的一个老缩写。 123456# 关闭图形界面sudo systemctl set-default multi-user.targetsudo reboot# 开启图形界面sudo systemctl set-default graphical.targetsudo reboot 如果安装使用的是中文，字符显示乱码 安装zhcon 1sudo apt install zhcon","categories":[],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"https://webwlsong.github.io/tags/ubuntu/"},{"name":"linux","slug":"linux","permalink":"https://webwlsong.github.io/tags/linux/"}]},{"title":"更换了Hexo博客主题pure使用","slug":"2020/2020-08/2020-08-30","date":"2020-08-29T16:00:00.000Z","updated":"2020-09-09T11:54:57.406Z","comments":true,"path":"2020/08/30/2020/2020-08/2020-08-30/","link":"","permalink":"https://webwlsong.github.io/2020/08/30/2020/2020-08/2020-08-30/","excerpt":"","text":"重新换了个清新的blog模版 看着还不错，后续坚持分享更多有。欢迎大家留言","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://webwlsong.github.io/tags/hexo/"},{"name":"pure","slug":"pure","permalink":"https://webwlsong.github.io/tags/pure/"}]},{"title":"基于微服务器 docker下的gitlab安装","slug":"2020/2020-08/2020-08-29","date":"2020-08-28T16:00:00.000Z","updated":"2020-09-09T11:54:57.407Z","comments":true,"path":"2020/08/29/2020/2020-08/2020-08-29/","link":"","permalink":"https://webwlsong.github.io/2020/08/29/2020/2020-08/2020-08-29/","excerpt":"","text":"docker gitlab安装 我是在开发机器上面安装 第一步 在宿主机器上面安装创建gitlab配置目录 1mkdir -p &#x2F;data&#x2F;gitlab&#x2F;&#123;config,logs,data&#125; 第二步 创建环境变量，指向本地宿主机存储gitlab配置的目录： 1export GITLAB_HOME&#x3D;&#x2F;data&#x2F;gitlab 第三步 运行镜像，创建容器： 12345678docker run --detach \\--hostname 127.0.0.1 \\-p 8443:443 -p 8880:80 -p 8822:22 \\--name gitlab --restart always \\-v $GITLAB_HOME&#x2F;config:&#x2F;etc&#x2F;gitlab \\-v $GITLAB_HOME&#x2F;logs:&#x2F;var&#x2F;log&#x2F;gitlab \\-v $GITLAB_HOME&#x2F;data:&#x2F;vat&#x2F;opt&#x2F;gitlab \\gitlab&#x2F;gitlab-ce:latest 使用命令lsof -i 端口号 查看端口是否被使用 其中由于宿主机的22端口被sshd服务使用，所以改为映射8822端口。80端口被暂用了，改成8880 https 已经被占用了。 注意： mac 1024一下的端口号需要 root权限 第四步 配置gitlab 配置gitlab 容器生成后，根据需要修改gitlab的配置，直接进入宿主机本地映射的config目录，编辑gitlab.rb文件; gitlab.rb文件内，主要需要配置的选项如下： 12345678910111213## GitLab NGINXnginx[&#39;listen_port&#39;] &#x3D; 80 # gitlab nginx 端口。默认端口为：80 ## GitLab Unicornunicorn[&#39;listen&#39;] &#x3D; &#39;localhost&#39;unicorn[&#39;port&#39;] &#x3D; 8080 #默认是8080端口 ## GitLab URL 配置http协议所使用的访问地址external_url GENERATED_EXTERNAL_URL&#39; # clone时显示的地址，gitlab 的域名 # 配置ssh协议所使用的访问地址和端口gitlab_rails[&#39;gitlab_ssh_host&#39;] &#x3D; &#39;song.local&#39;gitlab_rails[&#39;gitlab_shell_ssh_port&#39;] &#x3D; 8822 gitlab性能相关的选项如下： 123456789101112131415161718# 超时时间unicorn[&#39;worker_timeout&#39;] &#x3D; 60 #不能低于2，否则卡死 worker&#x3D;CPU核数+1 unicorn[&#39;worker_processes&#39;] &#x3D; 2 # 减少数据库缓存大小 默认256，可适当改小 postgresql[&#39;shared_buffers&#39;] &#x3D; &quot;256MB&quot; # 减少数据库并发数postgresql[&#39;max_worker_processes&#39;] &#x3D; 8 # 减少sidekiq并发数sidekiq[&#39;concurrency&#39;] &#x3D; 10 # 减少内存 unicorn[&#39;worker_memory_limit_min&#39;] &#x3D; &quot;200 * 1 &lt;&lt; 20&quot;unicorn[&#39;worker_memory_limit_max&#39;] &#x3D; &quot;300 * 1 &lt;&lt; 20&quot; 配置gitlab的邮箱服务： 1234567891011121314gitlab_rails[&#39;smtp_enable&#39;] &#x3D; truegitlab_rails[&#39;smtp_address&#39;] &#x3D; &quot;smtp.server&quot;gitlab_rails[&#39;smtp_port&#39;] &#x3D; 465gitlab_rails[&#39;smtp_user_name&#39;] &#x3D; &quot;smtp user&quot;gitlab_rails[&#39;smtp_password&#39;] &#x3D; &quot;smtp password&quot;gitlab_rails[&#39;smtp_domain&#39;] &#x3D; &quot;example.com&quot;gitlab_rails[&#39;smtp_authentication&#39;] &#x3D; &quot;login&quot;gitlab_rails[&#39;smtp_enable_starttls_auto&#39;] &#x3D; truegitlab_rails[&#39;smtp_openssl_verify_mode&#39;] &#x3D; &#39;peer&#39; # If your SMTP server does not like the default &#39;From: gitlab@localhost&#39; you# can change the &#39;From&#39; with this setting.gitlab_rails[&#39;gitlab_email_from&#39;] &#x3D; &#39;gitlab@example.com&#39;gitlab_rails[&#39;gitlab_email_reply_to&#39;] &#x3D; &#39;noreply@example.com&#39; 配置完成后，重启gitlab容器即可。 1docker restart ####","categories":[],"tags":[{"name":"docker","slug":"docker","permalink":"https://webwlsong.github.io/tags/docker/"},{"name":"gitlab","slug":"gitlab","permalink":"https://webwlsong.github.io/tags/gitlab/"}]},{"title":"php 基准测试对比。","slug":"2017-06-01","date":"2017-05-31T16:00:00.000Z","updated":"2020-09-09T11:54:57.402Z","comments":true,"path":"2017/06/01/2017-06-01/","link":"","permalink":"https://webwlsong.github.io/2017/06/01/2017-06-01/","excerpt":"","text":"php7 相比 Php5.6 提升 2-3 倍。 PHP7-JIT 相比 PHP5.6 提升 8 倍。 如果作为 php 开发者连鸟哥都不认识，起码不是很合格吧。下面是鸟哥做的测试对比。 下面是鸟哥做的分享。 为什么选择 php7？","categories":[],"tags":[{"name":"php","slug":"php","permalink":"https://webwlsong.github.io/tags/php/"},{"name":"php-jit","slug":"php-jit","permalink":"https://webwlsong.github.io/tags/php-jit/"}]},{"title":"operator mono vs fira code","slug":"2017-05-27","date":"2017-05-26T16:00:00.000Z","updated":"2020-09-18T00:57:40.407Z","comments":true,"path":"2017/05/27/2017-05-27/","link":"","permalink":"https://webwlsong.github.io/2017/05/27/2017-05-27/","excerpt":"","text":"operator mono 和 fira code 两个字体是目前世界上最好的字体。 1：看看别人的介绍 Operator Mono &amp; Fira Code — The Best of Both Worlds 2：Laravel作者 Eric L. Barnes用的也是这个字体。作者在推特上面发布出了他的配置 3：operator mono 是收费字体。fira code是免费字体。 如果在mac 安装 fira code 可以使用命令 brew cask install font-fira-code 最后提供一个 operator mono下载地址 链接: https://pan.baidu.com/s/1nvynUXF 密码: kezv 4:完成之后效果","categories":[{"name":"mono","slug":"mono","permalink":"https://webwlsong.github.io/categories/mono/"}],"tags":[{"name":"operator","slug":"operator","permalink":"https://webwlsong.github.io/tags/operator/"},{"name":"mono","slug":"mono","permalink":"https://webwlsong.github.io/tags/mono/"},{"name":"fira","slug":"fira","permalink":"https://webwlsong.github.io/tags/fira/"},{"name":"code","slug":"code","permalink":"https://webwlsong.github.io/tags/code/"}]},{"title":"Nginx 限流","slug":"2017-04-28-1","date":"2017-04-27T16:00:00.000Z","updated":"2020-09-09T11:54:57.401Z","comments":true,"path":"2017/04/28/2017-04-28-1/","link":"","permalink":"https://webwlsong.github.io/2017/04/28/2017-04-28-1/","excerpt":"","text":"电商平台营销时候，经常会碰到的大流量问题, 除了做流量分流处理，可能还要做用户黑白名单、信誉分析，进而根据用户ip信誉权重做相应的流量拦截、限制流量。Nginx自身有的请求限制模块ngx_http_limit_req_module、流量限制模块ngx_stream_limit_conn_module基于令牌桶算法，可以方便的控制令牌速率，自定义调节限流，实现基本的限流控制。 对于提供下载的网站，肯定是要进行流量控制的，例如软件下载站、视频服务等。它也可以减少一些爬虫程序或者DDOS的攻击。 对这两个模块的介绍的文章也不少，这里转载一篇hopestar的文章: nginx限制IP连接数的范例参考， 因为他介绍的很简洁。 如何Nginx限制同一个ip的连接数，限制并发数目: 1. 限流 添加limit_zone和limit_req_zone; 这个变量只能在http使用 : 1234vi /export/servers/nginx/conf/nginx.conf limit_zone one $binary_remote_addr 20m;limit_req_zone $binary_remote_addr zone=req_one:20m rate=12r/s; 添加limit_conn 和limit_req 这个变量可以在http, server, location使用 我是限制nginx上的所有服务，所以添加到http里面 （如果你需要限制部分服务，可在nginx/conf/domains里面选择相应的server或者location添加上便可） 12345vi /export/servers/nginx/conf/nginx.conf limit_zone one $binary_remote_addr 20m;limit_req_zone $binary_remote_addr zone=req_one:20m rate=12r/s;limit_conn one 10;limit_req zone=req_one burst=120; 参数详解(数值按具体需要和服务器承载能力设置,): 123456limit_zone，是针对每个变量(这里指IP，即$binary_remote_addr)定义一个存储session状态的容器。 这个示例中定义了一个20m的容器，按照32bytes/session， 可以处理640000个session。 limit_req_zone 与limit_zone类似。rate是请求频率. 每秒允许12个请求。limit_conn one 10 : 表示一个IP能发起10个并发连接数limit_req: 与limit_req_zone对应。burst表示缓存住的请求数。 示例： 123456789101112131415http&#123; limit_zone one $binary_remote_addr 20m; limit_req_zone $binary_remote_addr zone=req_one:20m rate=12r/s; limit_conn one 10; limit_req zone=req_one burst=120; server &#123; listen 80; server_name status.xxx.com ; location / &#123; stub_status on; access_log off; &#125; &#125;&#125; 重启nginx 1/export/servers/nginx/sbin/nginx -s reload 2. nginx白名单设置 以上配置会对所有的ip都进行限制，有些时候我们不希望对搜索引擎的蜘蛛或者某些自己的代理机过来的请求进行限制， 对于特定的白名单ip我们可以借助geo指令实现。 先在nginx的请求日志进行统计，查看那个ip的访问量比较大， 运行: 12cat access.log | grep &quot;03/Jun&quot; |awk &#x27;&#123;print $1&#125;&#x27;|sort |uniq -c|sort -nrk 1|head -n 10#列出访问日志里面在6月3号这天前10个访问量最大的ip. 接下来就可以对这些IP进行分析了。看哪些需要进行白名单设置。 12345678910111213141516http&#123; geo $limited &#123; # the variable created is $limited default 1; 127.0.0.1/32 0; 10.12.212.63 0; &#125; map $limited $limit &#123; 1 $binary_remote_addr; 0 &quot;&quot;; &#125; limit_zone one $binary_remote_addr 20m; limit_req_zone $limit zone=req_one:20m rate=20r/s; limit_conn one 10; limit_req zone=req_one burst=120;&#125; 上面两个需要用到map和geo模块，这是nginx自带的模块，有的运维喜欢把他们关闭，自己./sbin/nginx -V 留意一下。把配置的--whithout-XXX-module去掉重新编译一下就可以了。 上面这段配置的意思是： geo指令定义了一个白名单limited变量，默认值为1，如果客户端ip在上面的范围内，limited变量，默认值为1，如果客户端ip在上面的范围内，limited变量，默认值为1，如果客户端ip在上面的范围内，limited的值为0 使用map指令映射搜索引擎客户端的ip为空串，如果不是搜索引擎就显示本身真实的ip，这样搜索引擎ip就不能存到limit_req_zone内存session中，所以不会限制搜索引擎的ip访问 3. 获取客户端的真实IP 顺带一提，为了获取客户端的真实IP。该模块需要安装read_ip模块，运维应该默认有安装。没有的话也可自行安装： 配置方式相当简单，重新编译 Nginx 加上 --with-http_realip_module 参数，如： 123./configure --prefix=/opt/nginx --with-http_stub_status_module --with-pcre=../pcre-6.6 --with-http_realip_modulemakemake install 在server中增加: 123set_real_ip_from 192.168.1.0/24;set_real_ip_from 192.168.2.1;real_ip_header [X-Real-IP|X-Forwarded-For]; 需要说明的地方就是设置IP源的时候可以设置单个IP，也可以设置IP段，另外是使用X-Real-IP还是X-Forwarded-For，取决于前面的服务器有哪个头。 set_real_ip_from 设置的IP端可以让运维查看日志，看下你的请求是来自哪些ip段。 重新加载一下服务，差不多就OK了。 再查看日志的话，应该可以看到客户端的真实IP了。 注意：如果未安装该模块的话你的获取到的IP端可能是来自前端代理（如squid）的IP，结果就是多个用户被当成单个用户对待，导致应用不能响应。 再PS一下： 自测: 有条件的自己可以用ab或者webben自测一下。 未安装前压测的话，因为有大量请求，所以access.log会有大量日志，而error.log日志没有变化。 1234567➜ ~ webbench -c 30 -t 30 http://xxx.comWebbench - Simple Web Benchmark 1.5Copyright (c) Radim Kolar 1997-2004, GPL Open Source Software.Benchmarking: GET http://xxx.com 30 clients, running 30 sec.Speed=193468 pages/min, 1254317 bytes/sec.Requests: 96734 susceed, 0 failed. 安装后会发现很多超出的请求会返回503,所以access.log日志变化不快，error.log有大量记录,提示limit_reque缓住了多少请求。 1234567➜ ~ webbench -c 30 -t 30 http://xxxx.comWebbench - Simple Web Benchmark 1.5Copyright (c) Radim Kolar 1997-2004, GPL Open Source Software.Benchmarking: GET http://xxx.com 30 clients, running 30 sec.Speed=120 pages/min, 778 bytes/sec.Requests: 60 susceed, 0 failed.","categories":[],"tags":[{"name":"nginx","slug":"nginx","permalink":"https://webwlsong.github.io/tags/nginx/"}]},{"title":"Nginx 负载均衡策略","slug":"2017-04-28","date":"2017-04-27T16:00:00.000Z","updated":"2020-09-18T00:57:40.414Z","comments":true,"path":"2017/04/28/2017-04-28/","link":"","permalink":"https://webwlsong.github.io/2017/04/28/2017-04-28/","excerpt":"","text":"轮询（默认）每个web请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。 1234Upstream nginxDemo&#123; server 127.0.0.1:8001; server 127.0.0.1:8002;&#125; 最少链接web请求会被转发到连接数最少的服务器上。 12345Upstream nginxDemo&#123; least_conn; server 127.0.0.1:8001; server 127.0.0.1:8002;&#125; weight 权重指定轮询几率，weight和访问比率成正比，用 于后端服务器性能不均的情况，weight默认是1。 1234567#服务器A和服务器B的访问比例：2-1；比如有3个请求，前两个会访问A，第三个会访问B，其他的归着和轮询一样。Upstream nginxDemo&#123; least_conn; server 127.0.0.1:8001; server 127.0.0.1:8002;&#125; ip_hash每个请求按访问ip的hash值分配，这样同一客户端连续的Web请求都会被分发到同一服务器进行处理，可以解决session的问题。当后台服务器宕机时，会自动跳转到其它服务器。基于weight的负载均衡和基于ip_hash的负载均衡可以组合在一起使用。 12345ip_hash;Upstream nginxDemo&#123; server 127.0.0.1:8001 weight&#x3D;2; #服务器A server 127.0.0.1:8002; #服务器B&#125; url_hash（第三方）url_hash是nginx的第三方模块，nginx本身不支持，需要打补丁。nginx按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存服务器、文件服务器、静态服务器时比较有效。缺点是当后端服务器宕机的时候，url_hash不会自动跳转的其他缓存服务器，而是返回给用户一个503错误。 12345Upstream nginxDemo&#123; server 127.0.0.1:8001 weight&#x3D;2; #服务器A server 127.0.0.1:8002; #服务器B hash $request_url;&#125; fair（第三方）按后端服务器的响应时间来分配请求，响应时间短的优先分配。 12345Upstream nginxDemo&#123; server 127.0.0.1:8001 weight&#x3D;2; #服务器A server 127.0.0.1:8002; #服务器B hair;&#125;","categories":[{"name":"nginx","slug":"nginx","permalink":"https://webwlsong.github.io/categories/nginx/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"https://webwlsong.github.io/tags/nginx/"}]},{"title":"IntelliJ Idea 2017 免费激活方法","slug":"2017-04-27","date":"2017-04-26T16:00:00.000Z","updated":"2020-09-09T11:54:57.404Z","comments":true,"path":"2017/04/27/2017-04-27/","link":"","permalink":"https://webwlsong.github.io/2017/04/27/2017-04-27/","excerpt":"","text":"第一种方法： 到网站 http://idea.lanyus.com/ 获取注册码。 第二种方法： 首先：0.0.0.0 account.jetbrains.com 添加到hosts 填入下面的license server: http://intellij.mandroid.cn/ http://idea.imsxm.com/ http://idea.iteblog.com/key.php 以上方法验证均可以","categories":[],"tags":[{"name":"phpstrom","slug":"phpstrom","permalink":"https://webwlsong.github.io/tags/phpstrom/"},{"name":"jetbrains","slug":"jetbrains","permalink":"https://webwlsong.github.io/tags/jetbrains/"}]},{"title":"php nodejs nginx 进程模型对比","slug":"2017-04-25","date":"2017-04-24T16:00:00.000Z","updated":"2020-09-09T11:54:57.403Z","comments":true,"path":"2017/04/25/2017-04-25/","link":"","permalink":"https://webwlsong.github.io/2017/04/25/2017-04-25/","excerpt":"","text":"PHP 进程模型 PHP-FPM 是 PHP 针对 FastCGI 协议的具体实现，也是 PHP 在多种服务器端应用编程端口（SAPI：cgi、fast-cgi、cli、isapi、apache）里使用最普遍、性能最佳的一款进程管理器。 PHP-FPM 这种模型是非常典型的多进程同步模型，意味着一个请求对应一个进程线程，并且 IO 是同步阻塞的。所以尽管 PHP-FPM 维护着独立的 CGI 进程池、系统也可以很轻松的管理进程的生命周期， 受制于服务器的硬件设施，PHP-FPM 需要指定合理的 php-fpm.conf 配置： 12345pm.max_children # 子进程最大数pm.start_servers # 启动时的子进程数pm.min_spare_servers # 最小空闲进程数，空闲进程不够时自动补充pm.max_spare_servers # 最大空闲进程数，空闲进程超过时自动清理pm.max_requests &#x3D; 1000 # 子进程请求数阈值，超过后自动回收 PHP 进程本身并不存在内存泄露的问题，每个进程完成请求处理后会回收内存，但是并不会释放给操作系统，这就导致大量内存被 PHP-FPM 占用而无法释放，请求量升高时性能骤降。 所以 PHP-FPM 需要控制单个子进程请求次数的阈值。很多人会误以为 max_requests 控制了进程的并发连接数，实际上 PHP-FPM 模式下的进程是单一线程的，请求无法并发。这个参数的真正意义是提供请求计数器的功能，超过阈值数目后自动回收，缓解内存压力。 nginx进程模型 Nginx 是非阻塞IO &amp; IO复用模型，通过操作系统提供的类似 epoll 的功能，可以在一个线程里处理多个客户端的请求。 Nginx 的进程就是线程，即每个进程里只有一个线程，但这一个线程可以服务多个客户端。 nginx在启动后，会有一个master进程和多个worker进程。master进程主要用来管理worker进程，包含：接收来自外界的信号，向各worker进程发送信号，监控worker进程的运行状态，当worker进程退出后(异常情况下)，会自动重新启动新的worker进程。而基本的网络事件，则是放在worker进程中来处理了。多个worker进程之间是对等的，他们同等竞争来自客户端的请求，各进程互相之间是独立的。一个请求，只可能在一个worker进程中处理，一个worker进程，不可能处理其它进程的请求。worker进程的个数是可以设置的，一般我们会设置与机器cpu核数一致，这里面的原因与nginx的进程模型以及事件处理模型是分不开的 因此才有了异步非阻塞的事件处理机制。具体到系统调用就是像select/poll/epoll/kqueue这样的系统调用。他们提供了一种机制，让你可以同时监控多个事件，调用他们是阻塞的，但可以设置超时时间，在超时时间之内，如果有事件准备好了，就返回。这种机制解决了我们上面两个问题。 以epoll为例：当事件没有准备好时，就放入epoll里面。如果有事件准备好了，那么就去处理；如果事件返回的是EAGAIN，那么继续将其放入epoll里面。从而，只要有事件准备好了，我们就去处理她，只有当所有时间都没有准备好时，才在epoll里面等着。这样，我们就可以并发处理大量的并发了，当然，这里的并发请求，是指未处理完的请求，线程只有一个，所以同时能处理的请求当然只有一个了，只是在请求间进行不断地切换而已，切换也是因为异步事件未准备好，而主动让出的。这里的切换是没有任何代价，你可以理解为循环处理多个准备好的事件，事实上就是这样的。 nodejs 进程模型 我们都知道nodejs最大的特点就是单进程、无阻塞运行，并且是异步事件驱动的。Nodejs的这些特性能够很好的解决一些问题，例如在服务器开发中，并发的请求处理是个大问题，阻塞式的函数会导致资源浪费和时间延迟。通过事件注册、异步函数，开发人员可以提高资源的利用率，性能也会改善。既然Node.js采用单进程、单线程模式，那么在如今多核硬件流行的环境中，单核性能出色的Nodejs如何利用多核CPU呢？创始人Ryan Dahl建议，运行多个Nodejs进程，利用某些通信机制来协调各项任务。目前，已经有不少第三方的Node.js多进程支持模块发布，而NodeJS 0.6.x 以上的版本提供了一个cluster模块 ,允许创建“共享同一个socket”的一组进程,用来分担负载压力。","categories":[],"tags":[{"name":"php","slug":"php","permalink":"https://webwlsong.github.io/tags/php/"},{"name":"nodejs","slug":"nodejs","permalink":"https://webwlsong.github.io/tags/nodejs/"},{"name":"nginx","slug":"nginx","permalink":"https://webwlsong.github.io/tags/nginx/"}]},{"title":"测试一下 qq和淘宝网页的测试","slug":"2017-04-17","date":"2017-04-16T16:00:00.000Z","updated":"2020-09-09T11:54:57.427Z","comments":true,"path":"2017/04/17/2017-04-17/","link":"","permalink":"https://webwlsong.github.io/2017/04/17/2017-04-17/","excerpt":"","text":"为什么做这个测试？最近有人你们的app接口能支持多大的并发，能支持多少的用户。 答： 这个本身就是个伪命题，没有场景话，很难回答。就好像，你们怎么做优化，这本身也是个伪命题。 如果要回答，网上google一下，有很多，问题在于你们的场景能用的到吗？如果要谈，这个很大的话题。 每个话题展开都能谈很久。 延迟分析 同城机房网络(0.5ms~2ms) max(1000qps) jvm-gc(50ms左右) max(20qps) 如果是异地机房，例如北京到上海机房，一次网络往返可能就13～20毫秒延迟。max(50qps) ![测试图](2017-04-17 at 14.04.47.gif) （测试图）","categories":[],"tags":[{"name":"性能测试","slug":"性能测试","permalink":"https://webwlsong.github.io/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"}]},{"title":"docker ubuntu ping source 不能使用","slug":"2016-11-28","date":"2016-11-27T16:00:00.000Z","updated":"2020-09-09T11:54:57.399Z","comments":true,"path":"2016/11/28/2016-11-28/","link":"","permalink":"https://webwlsong.github.io/2016/11/28/2016-11-28/","excerpt":"","text":"使用docker 拉取ubunut 镜像 我本地使用的ubuntu 镜像版本如下： 1234sh-4.3# cat &#x2F;etc&#x2F;issueUbuntu 16.04.1 LTS \\n \\lsh-4.3# 拉取ubuntu进行，你会发现有的镜像Ping都不通 解决方法： apt-get update 更新源 source 和 ubunut的代码补全也不能使用 shell脚本中source 时提示 source: not found Debian和Ubuntu中，/bin/sh默认已经指向dash，这是一个不同于bash的shell，它主要是为了执行脚本而出现，而不是交互，它速度更快，但功能相比bash要少很多，语法严格遵守POSIX标准 dash不是为交互而生的，所以我们在使用过程中还是习惯的修改成bash 123ls -l &#x2F;bin&#x2F;sh 显示 &#x2F;bin&#x2F;sh -&gt;dash 显示使用的是dash 修改默认的shell 1234sudo dpkg-reconfigure dash再次检查一下， ls &#x2F;bin&#x2F;sh -al 发现软链接指向&#x2F;bin&#x2F;bash 恢复ubuntu bash下的自动补全 1234561. 确认&#x2F;etc&#x2F;bash_completion是否存在，如果没有就安装一个：2. apt-get install bash-completion在用户的shell中运行：3. source &#x2F;etc&#x2F;bash_completion 添加新的用户 ubuntn下面 1234567891011useradd -m username &#x2F;&#x2F;ubuntu 自动创建用户目录passwd username &#x2F;&#x2F;创建密码usermod -a -G sudo username &#x2F;&#x2F;用户拥有权限ubuntu 默认的是dash shell修改成 bashvi &#x2F;etc&#x2F;passwd 1.username:x:1000:1000::&#x2F;home&#x2F;username修成成如下：2. username:x:1000:1000::&#x2F;home&#x2F;username:&#x2F;bin&#x2F;bash","categories":[],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"https://webwlsong.github.io/tags/ubuntu/"},{"name":"docker","slug":"docker","permalink":"https://webwlsong.github.io/tags/docker/"}]},{"title":"解决go delve 不能使用 OS X cannot get thread count","slug":"2016-11-26","date":"2016-11-25T16:00:00.000Z","updated":"2020-09-09T11:54:57.402Z","comments":true,"path":"2016/11/26/2016-11-26/","link":"","permalink":"https://webwlsong.github.io/2016/11/26/2016-11-26/","excerpt":"","text":"go Delve 报错 mac 解决方法如下： 我的go版本 ：go version go1.7.3 darwin/amd64 https://github.com/derekparker/delve/issues/645 ` go into your GOPATH create folder $GOPATH/src/github.com/derekparker/, and go into this folder. ‘cd $GOPATH/src/github.com/derekparker/’ git clone https://github.com/derekparker/delve.git cd delve git fetch origin pull/665/head git checkout FETCH_HEAD CERT=dlv-cert make install `","categories":[],"tags":[{"name":"go","slug":"go","permalink":"https://webwlsong.github.io/tags/go/"},{"name":"delve","slug":"delve","permalink":"https://webwlsong.github.io/tags/delve/"}]},{"title":"用swoole TCP Server 和mongodb做数据备份和恢复","slug":"mongo-php-error","date":"2016-05-18T10:52:40.000Z","updated":"2020-09-09T11:54:57.403Z","comments":true,"path":"2016/05/18/mongo-php-error/","link":"","permalink":"https://webwlsong.github.io/2016/05/18/mongo-php-error/","excerpt":"","text":"应用场景是，单个用户写的数据是8-10条/S JSON数据包 采用架构如下图所示： 采用的是 php7.0.6 swoole-1.8.5版本 php扩展mongodb1.1.6 而目前mongo-1.6.14不支持php7 这样导致连接Mongo函数不一样，后面会讲到。 服务器 Ubuntu 14.04 64位 2核 4G 阿里云的Mongodb服务器 到目前阿里云Mongodb还不支持sharding,后续会进行支持。目前是使用双节点。摘录MongoDB杭州用户交流会的一段话: 阿里云目前已提供对MongoDB复制集（Replica Set）的支持，默认会为用户创建包含3个数据节点的复制集，其中一个Primary、一个Secondary，以及一个Hidden节点。Primary、Secondary对用户可见，用户可以自定义ReadPreference，Hidden节点对用户不可见，目前主要用于实例数据备份以及自动的failover，当有Primary或Secondary节点挂掉时，Hidden会被自动切换为Secondary，保证用户的服务不受影响。 mongodb服务器 阿里云服务器目前只支持ECS访问不支持外网方面 [公网连接mongodb windows篇](https://help.aliyun.com/knowledge_detail/13052608.html#通过公网连接云数据库MongoDB--ECS Windows篇) [公网连接mongodb linux篇](https://help.aliyun.com/knowledge_detail/13052572.html#通过公网连接云数据库MongoDB--ECS Linux篇) 用如下命令检测是否连上mongodb ping dds-xxxxxxxx.mongodb.rds.aliyuncs.com telnet dds-xxxxxxxxxxxx.mongodb.rds.aliyuncs.com 3717 mongo --host dds-xxxxxxxxxxxxx1.mongodb.rds.aliyuncs.com:3717 --authenticationDatabase admin -u root -p mongo --host dds-xxxxxxxxxxxxxx2.mongodb.rds.aliyuncs.com:3717 --authenticationDatabase admin -u root -p 如果本身server服务器用的ECS，还是要设置一下， 搭建TCP-SEVER服务器 买好服务器之后习惯性的把服务器服务升级到最新。（这个是强迫症） 123$ apt-get update $ apt-get upgrade 安装最新的php7.0.6环境 12345678910111213141516171819202122232425262728293031323334353637apt-get install python-software-propertiesapt-get install software-properties-commonLC_ALL=C.UTF-8 add-apt-repository ppa:ondrej/phpapt-get updateapt-cache show php7.0-dev Package: php7.0-devSource: php7.0Priority: optionalSection: phpInstalled-Size: 4658Maintainer: Debian PHP Maintainers &lt;pkg-php-maint@lists.alioth.debian.org&gt;Architecture: amd64Version: 7.0.6-12+donate.sury.org~trusty+1Recommends: dh-php, pkg-php-toolsDepends: autoconf (&gt;= 2.63), automake (&gt;= 1.11), libpcre3-dev, libssl-dev, php7.0-cli (&gt;= 7.0.6-12+donate.sury.org~trusty+1), php7.0-common (= 7.0.6-12+donate.sury.org~trusty+1), shtool, libtoolFilename: pool/main/p/php7.0/php7.0-dev_7.0.6-12+donate.sury.org~trusty+1_amd64.debSize: 505784MD5sum: bb75fadf2fc0bae22d7a26999b9ac0e2SHA1: a85e13a259faae1377813d7b1e5c344c8ede8d09SHA256: 79617d3b79e054129a2e980534885ab794ec18c5052894e71d1da37ec07b2affDescription-en: Files for PHP7.0 module development This package provides the files from the PHP7.0 source needed for compiling additional modules.PHP (recursive acronym for PHP: Hypertext Preprocessor) is a widely-used open source general-purpose scripting language that is especially suited for web development and can be embedded into HTML.Description-md5: cab4eaaf141b1f52bc2814eea2492ab2apt-get install php7.0-dev 安装mongo扩展 和swoole扩展 123456789101112131415161718192021222324252627282930使用pecl进行安装mongo和swoole扩展。这里记住是mongodb扩展不是mongo扩展。这两个扩展在使用上面不一样，后面会讲到。这里我们安装mongodb搜索mongodb$ pecl search mongopecl库更新到最新$ pecl channel-update pecl.php.net安装mongodb$ pecl install mongodb问题：1. 这里如果安装mongo会提示不支持Php7.0以上版本： pecl&#x2F;mongo requires PHP (version &gt;&#x3D; 5.3.0, version &lt;&#x3D; 5.99.99), installed version is 7.0.6-12+donate.sury.org~trusty+12. configure: error: Cannot find OpenSSL&#39;s libraries 解决方法： ln -s &#x2F;usr&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libssl.so &#x2F;usr&#x2F;lib安装swoole$ pecl install swoole查找php.ini 把swoole.so和mongodb加入进去$ php --ini $ php -ri|grep swoole PHP swoole代码 123456789101112131415161718192021222324252627282930313233343536$serv = new swoole_server(&quot;0.0.0.0&quot;, 9501);$serv-&gt;set(array( &#x27;worker_num&#x27; =&gt; 8, //工作进程数量 &#x27;daemonize&#x27; =&gt; false, //是否作为守护进程));$serv-&gt;on(&#x27;connect&#x27;, function ($serv, $fd) &#123; echo &quot;Client:Connect.\\n&quot;;&#125;);$serv-&gt;on(&#x27;receive&#x27;, function ($serv,$fd, $from_id, $data) &#123; $arr = json_decode($data); //$array=array(&#x27;column_name&#x27;=&gt;&#x27;col&#x27;.rand(100,999),&#x27;column_exp&#x27;=&gt;&#x27;xiaocai&#x27;); $connection = new MongoClient(&quot;mongodb://root:密码@主机ID1.mongodb.rds.aliyuncs.com:3717,主机2.mongodb.rds.aliyuncs.com:3717/admin?replicaSet=副本集名称&quot;); // $connection = new MongoClient(&quot;mongodb://localhost:27017&quot;); var_dump($connection); $roomid = &quot;roomid&quot;.&#x27;_123&#x27;; $collection = $connection-&gt;test-&gt;$roomid; $collection-&gt;insert($arr); $document = $collection-&gt;findOne(); var_dump($document); $serv-&gt;send($fd, &#x27;Swoole: &#x27; . $data); $serv-&gt;close($fd);&#125;);$serv-&gt;on(&#x27;close&#x27;, function ($serv, $fd) &#123; echo &quot;Client: Close.\\n&quot;;&#125;);$serv-&gt;start(); 如果执行上面的代码的话，会报PHP Fatal error: Uncaught Error: Class 'MongoClient' not found 这里要说明一下MongoClient是扩展Mongo的内置函数。 可以通过 1print_r(get_declared_classes()); 查看函数列表 Mongo的函数列表 123456789101112131415161718192021222324252627282930313233343536[156] &#x3D;&gt; MongoClient[157] &#x3D;&gt; Mongo[158] &#x3D;&gt; MongoDB[159] &#x3D;&gt; MongoCollection[160] &#x3D;&gt; MongoCursor[161] &#x3D;&gt; MongoCommandCursor[162] &#x3D;&gt; MongoGridFS[163] &#x3D;&gt; MongoGridFSFile[164] &#x3D;&gt; MongoGridFSCursor[165] &#x3D;&gt; MongoWriteBatch[166] &#x3D;&gt; MongoInsertBatch[167] &#x3D;&gt; MongoUpdateBatch[168] &#x3D;&gt; MongoDeleteBatch[169] &#x3D;&gt; MongoId[170] &#x3D;&gt; MongoCode[171] &#x3D;&gt; MongoRegex[172] &#x3D;&gt; MongoDate[173] &#x3D;&gt; MongoBinData[174] &#x3D;&gt; MongoDBRef[175] &#x3D;&gt; MongoException[176] &#x3D;&gt; MongoConnectionException[177] &#x3D;&gt; MongoCursorException[178] &#x3D;&gt; MongoCursorTimeoutException[179] &#x3D;&gt; MongoGridFSException[180] &#x3D;&gt; MongoResultException[181] &#x3D;&gt; MongoWriteConcernException[182] &#x3D;&gt; MongoDuplicateKeyException[183] &#x3D;&gt; MongoExecutionTimeoutException[184] &#x3D;&gt; MongoProtocolException[185] &#x3D;&gt; MongoTimestamp[186] &#x3D;&gt; MongoInt32[187] &#x3D;&gt; MongoInt64[188] &#x3D;&gt; MongoLog[189] &#x3D;&gt; MongoPool[190] &#x3D;&gt; MongoMaxKey[191] &#x3D;&gt; MongoMinKey Mongodb的函数列表 1234567891011121314151617181920212223242526272829303132[100] &#x3D;&gt; MongoDB\\Driver\\Command [101] &#x3D;&gt; MongoDB\\Driver\\Cursor [102] &#x3D;&gt; MongoDB\\Driver\\CursorId [103] &#x3D;&gt; MongoDB\\Driver\\Manager [104] &#x3D;&gt; MongoDB\\Driver\\Query [105] &#x3D;&gt; MongoDB\\Driver\\ReadConcern [106] &#x3D;&gt; MongoDB\\Driver\\ReadPreference [107] &#x3D;&gt; MongoDB\\Driver\\Server [108] &#x3D;&gt; MongoDB\\Driver\\BulkWrite [109] &#x3D;&gt; MongoDB\\Driver\\WriteConcern [110] &#x3D;&gt; MongoDB\\Driver\\WriteConcernError [111] &#x3D;&gt; MongoDB\\Driver\\WriteError [112] &#x3D;&gt; MongoDB\\Driver\\WriteResult [113] &#x3D;&gt; MongoDB\\Driver\\Exception\\LogicException [114] &#x3D;&gt; MongoDB\\Driver\\Exception\\RuntimeException [115] &#x3D;&gt; MongoDB\\Driver\\Exception\\UnexpectedValueException [116] &#x3D;&gt; MongoDB\\Driver\\Exception\\InvalidArgumentException [117] &#x3D;&gt; MongoDB\\Driver\\Exception\\ConnectionException [118] &#x3D;&gt; MongoDB\\Driver\\Exception\\AuthenticationException [119] &#x3D;&gt; MongoDB\\Driver\\Exception\\SSLConnectionException [120] &#x3D;&gt; MongoDB\\Driver\\Exception\\WriteException [121] &#x3D;&gt; MongoDB\\Driver\\Exception\\BulkWriteException [122] &#x3D;&gt; MongoDB\\Driver\\Exception\\ExecutionTimeoutException [123] &#x3D;&gt; MongoDB\\Driver\\Exception\\ConnectionTimeoutException [124] &#x3D;&gt; MongoDB\\BSON\\Binary [125] &#x3D;&gt; MongoDB\\BSON\\Javascript [126] &#x3D;&gt; MongoDB\\BSON\\MaxKey [127] &#x3D;&gt; MongoDB\\BSON\\MinKey [128] &#x3D;&gt; MongoDB\\BSON\\ObjectID [129] &#x3D;&gt; MongoDB\\BSON\\Regex [130] &#x3D;&gt; MongoDB\\BSON\\Timestamp [131] &#x3D;&gt; MongoDB\\BSON\\UTCDateTime 所以要使用Php7.0以上版本需要重新写连接mongdo的数据库 查找php文档Mongodb driver 修改成为mongodb的一个demo 连接修改代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162$serv = new swoole_server(&quot;0.0.0.0&quot;, 9501);$serv-&gt;set(array( &#x27;worker_num&#x27; =&gt; 8, //工作进程数量 &#x27;daemonize&#x27; =&gt; false, //是否作为守护进程));$serv-&gt;on(&#x27;connect&#x27;, function ($serv, $fd) &#123; echo &quot;Client:Connect.\\n&quot;;&#125;);$serv-&gt;on(&#x27;receive&#x27;, function ($serv, $fd, $from_id, $data) &#123; $arr = json_decode($data); $bulk = new MongoDB\\Driver\\BulkWrite([&#x27;ordered&#x27; =&gt; true]); $bulk-&gt;insert($arr); $connection = new MongoDB\\Driver\\Manager(&quot;mongodb://localhost:27017&quot;); try &#123; $result = $connection-&gt;executeBulkWrite(&#x27;test.roomid&#x27;, $bulk); &#125; catch (MongoDB\\Driver\\Exception\\BulkWriteException $e) &#123; $result = $e-&gt;getWriteResult(); if ($writeConcernError = $result-&gt;getWriteConcernError()) &#123; printf(&quot;%s (%d): %s\\n&quot;, $writeConcernError-&gt;getMessage(), $writeConcernError-&gt;getCode(), var_export($writeConcernError-&gt;getInfo(), true)); &#125; // Check if any write operations did not complete at all foreach ($result-&gt;getWriteErrors() as $writeError) &#123; printf(&quot;Operation#%d: %s (%d)\\n&quot;, $writeError-&gt;getIndex(), $writeError-&gt;getMessage(), $writeError-&gt;getCode() ); &#125; &#125; catch (MongoDB\\Driver\\Exception\\Exception $e) &#123; printf(&quot;Other error: %s\\n&quot;, $e-&gt;getMessage()); exit;&#125; printf(&quot;Inserted %d document(s)\\n&quot;,$result-&gt;getInsertedCount()); printf(&quot;Updated %d document(s)\\n&quot;,$result-&gt;getModifiedCount()); $serv-&gt;send($fd, &#x27;Swoole: &#x27; . $data); $serv-&gt;close($fd);&#125;);$serv-&gt;on(&#x27;close&#x27;, function ($serv, $fd) &#123; echo &quot;Client: Close.\\n&quot;; &#125;);$serv-&gt;start(); 模拟请求数据 1netcat 127.0.0.1 9501 END","categories":[],"tags":[{"name":"mongo","slug":"mongo","permalink":"https://webwlsong.github.io/tags/mongo/"},{"name":"php-mongo","slug":"php-mongo","permalink":"https://webwlsong.github.io/tags/php-mongo/"},{"name":"swoole","slug":"swoole","permalink":"https://webwlsong.github.io/tags/swoole/"},{"name":"tcp","slug":"tcp","permalink":"https://webwlsong.github.io/tags/tcp/"}]},{"title":"go基本语法","slug":"go-sty01","date":"2016-04-28T07:25:02.000Z","updated":"2020-09-18T00:58:30.238Z","comments":true,"path":"2016/04/28/go-sty01/","link":"","permalink":"https://webwlsong.github.io/2016/04/28/go-sty01/","excerpt":"","text":"变量和赋值 在go 语言中声明和赋值是分开的需要两步，也可以写成一步 1234var a intvar b boola = 5b = false 或者写成一步 12a :=5b :=false 多个var声明可以成组 1234var( x int b bool) 具备相同的类型多个变量可以在一行内完成声明：var x,y int 让x 和 y 都是 int 类型变量。同样也可以平行赋值 1a,b := 20,16 这样让a和b的值分别是20和16 一些特殊的变量名是_(下划线)。标示任何赋值给他的都会抛弃掉。 例如： 1_,b :=1,2 这样抛弃掉1 把b赋值为2. 数字类型(Number) 数值类型有三种，一种是整数类型，另外一种是浮点型, 还有一种是虚数类型。正整数和零统称为: 无符号整型, 而负整数称为: 有符号整型。 无符号类型能够表示正整数和零。而有符号类型除了能够表示正整数和零外，还可以表示负整数。 另外还有一些别名类型，比如byte类型，这个类型和uint8是一样的，表示字节类型。另外一个是rune类型，这个类型和int32是一样的，用来表示unicode的代码点，就是unicode字符所对应的整数。 Go还定义了三个依赖系统的类型，uint，int和uintptr。因为在32位系统和64位系统上用来表示这些类型的位数是不一样的。 12345678对于32位系统uint=uint32int=int32uintptr为32位的指针对于64位系统uint=uint64int=int64uintptr为64位的指针 至于类型后面跟的数字8，16，32或是64则表示用来表示这个类型的位不同，位越多，能表示的整数范围越大。 比如对于用N位来表示的整数，如果是有符号的整数，能够表示的整数范围为-2^(N-1) ~ 2^(N-1)－1；如果是无符号的整数，则能表示的整数范围为0 ～ 2^(N-1)。 Go的浮点数类型有两种，float32和float64。float32又叫单精度浮点型，float64又叫做双精度浮点型。其最主要的区别就是小数点后面能跟的小数位数不同. 另外Go还有两个其他语言所没有的类型，虚数类型。complex64和complex128。 对于数值类型，其所共有的操作为加法(＋)，减法(－)，乘法(＊)和除法(/)。另外对于整数类型，还定义了求余运算(%) 123456789101112package mainimport ( &quot;fmt&quot;)func main() &#123; var a float64 = 12 var b float64 = 3 fmt.Println(a % b)&#125;","categories":[{"name":"go","slug":"go","permalink":"https://webwlsong.github.io/categories/go/"},{"name":"golang","slug":"go/golang","permalink":"https://webwlsong.github.io/categories/go/golang/"}],"tags":[{"name":"go","slug":"go","permalink":"https://webwlsong.github.io/tags/go/"},{"name":"golang","slug":"golang","permalink":"https://webwlsong.github.io/tags/golang/"}]},{"title":"架构设计图","slug":"hw-jg","date":"2016-04-21T09:51:31.000Z","updated":"2020-09-09T11:54:57.404Z","comments":true,"path":"2016/04/21/hw-jg/","link":"","permalink":"https://webwlsong.github.io/2016/04/21/hw-jg/","excerpt":"","text":"今天抽点时间把产品架构图给画出来了。","categories":[],"tags":[{"name":"架构","slug":"架构","permalink":"https://webwlsong.github.io/tags/%E6%9E%B6%E6%9E%84/"}]},{"title":"创业公司入职3年小结","slug":"ranyao-chuangye","date":"2016-04-20T14:07:23.000Z","updated":"2020-09-09T11:54:57.429Z","comments":true,"path":"2016/04/20/ranyao-chuangye/","link":"","permalink":"https://webwlsong.github.io/2016/04/20/ranyao-chuangye/","excerpt":"","text":"在创业公司3年多，学到了很多东西，也历练了很多，也见识了很多，后面会专门写几篇关于我在创业公司经历，大致从产品迭代开发，创业公司喜欢什么类型的人才，怎么在创业公司工作几个方面来介绍。本篇主要是入职3年小结 我们的产品在使用和用过那些技术 服务器端：PHP语言 数据库：MYSQL 缓存 redis memcache Android: Android原生 IOS: Object-c, Swift PC: c# WPF MVVM 流媒体： C,C++ SRS和自建RTMP-server,webRTC 服务器：阿里云云服务 （20+台） 云存储： 七牛 第三方厂家：云信IM和短信，SendCloud（邮件）极光推送（消息）Openfire, bugtags,友盟，支付支付和微信支付 后面想到在补充 入职的第一年 2013年2-3月份开始着手做教育产品，往往产品模型和软件架构是密切相关的，第一年我们只做了Android Pad，是一个大而全的产品封闭性的产品。起初软硬件都打算做的，先从软件做起，那个时候开模没有100W都很难做。所以当时公司经理和技术总监决定从软件开始做起，做了仿launcher,里面可以嵌入自己的App,其他的厂家的App,类似一个Android Rom的一个东西。当时做了及时问和考试苑。那个时候我主要负责服务器端开发，负责服务器基础架构，技术选型，服务器端人员招聘等工作。说白了，就是一个主程序员。 是否使用云服务器还是仔细斟酌考虑，采用自购服务器托管（当时主流），还是用云服务器。通过测试几家云服务器商（Ucloud,AWS,阿里云）,最终选择了阿里云，即使当时有很多对云服务器有很多谩骂声，但是针对我们小企业来说，云服务器是个不二的选择，至今我们都认为是正确的选择。这里还有个小插曲，我们在通宵测试对比Ucloud，那天晚上他们服务器正好升级，白忙活了。 云存储MFS的年代，当时也测试对比又拍云和七牛还有阿里云的OSS存储。 入职第二年 公司经理和技术总监离职，大股东进入，因为表现比较好，转升为技术总监。产品方向转向做移动App。还是以Android Pad为主，实现双向互动。我们也从小的办公场地搬到一个大的办公场地，开始了招兵买马。陆陆续续 流媒体组，测试组，设计组也细化开来分成UI和UE。流媒体部分还从做监控行业找到一个从业10来年经验的一个同事（却为后面埋下祸根）。由8-9个研发团队翻了了一倍，15-16个 这一年我们做了很多基础架构方面的事情，jenkins集成发布和测试，使用jenkins打包android。由原生git管理，迁移到gitlab，使用git flow 去管理。我也由ubuntu转成MAC平台开发。把云存储由阿里云OSS转向到七牛。（这个上周阿里云过来拜访来提到这个事情，起初对OSS不是很重视，出了很多问题）.那一年我们还完善了考试苑web端的开发，以及移动的考试苑api，和当时梯子网类似，同时还上了微课集模块，也已经在着手做教育云盘。 这一年我们公司也做了几次大的活动，包括和一些其他公司合作共赢开发，资源互换等尝试。这一年我们又有一次深刻的通宵经历，全司通宵修改版本，为第二天发布会做准备。虽然很辛苦，但是还是很快乐。 这一年我们还开始认识到手机应该是主流，同时要启动ios的开发。这一年结束之后不是很理想，陆续有人提出离职。也是这一年开始了解Docker方面的。 入职第三年 这一年最苦的时候服务器端只剩下我一人，同年5月我们获得了中信证券，银河证券 A轮 3000W的融资，后期慢慢有把这个团队重新组建起来，在后来我就从服务器端退出来，交给一个PHP资深的同事负责（英语比国语说的好 在互联网10来年经验的人），这一年服务器端进行了一次架构升级，同年我们开始从内部选拔人员转做IOS开发，组建IOS组，从Android和流媒体组自愿转岗到IOS，有一个经验非常丰富的同时带领，也是我招聘进来最得意的一位同事，技术非常全面。也是天天动听比较早期的员工。经历过创业和在大公司是完全不同的人。 流媒体也从原来的只支持Android，向全端支持，进行一次架构升级。Android端也进行了一次软件架构的升级。 为了优化书写感知，同年8月我们启动PC版本的开发。B/S和C/S架构上面抉择，最终我们选择了C/S架构的PC端。主要是考虑到和第三方手写板兼容性更好，B/S架构还的需求写插件支持才可以。 起初没有人会开发C/S或者我们在这个方面都没有经验，现在做WPF或者WCF的人少之又少，采用外包的方式。后面发现作为公司的产品外包是根本行不通，在产品不断的要进行修改，外包根本满足不了我们的需求。最后还的重新组建PC团队。补充流媒体团队的实力，流媒体中间件人员，主要做流媒体和M的对接工作。版本比较的多，测试人员我们也的扩充。研发团队扩展到目前团队23人。 后面公司也收购了一个市场团队。专做市场推广。 先写到这里吧","categories":[],"tags":[]},{"title":"开篇","slug":"开篇","date":"2016-04-20T06:33:43.000Z","updated":"2020-09-09T11:54:57.401Z","comments":true,"path":"2016/04/20/开篇/","link":"","permalink":"https://webwlsong.github.io/2016/04/20/%E5%BC%80%E7%AF%87/","excerpt":"","text":"blog开篇 从2006年一直写到2013年1月6号最后一篇，总共500多篇。虽然Blog建了很长时间了，一直想继续去写，出于没有太时间去整理，原因baidu blog关闭了之后在也没有更新一遍Blog。作为一个老码农，总有个情怀，把自己项目中遇到的问题给记录记下来，看到好的文章转载收藏。","categories":[],"tags":[]}],"categories":[{"name":"小程序","slug":"小程序","permalink":"https://webwlsong.github.io/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"python","slug":"python","permalink":"https://webwlsong.github.io/categories/python/"},{"name":"go","slug":"go","permalink":"https://webwlsong.github.io/categories/go/"},{"name":"内存","slug":"go/内存","permalink":"https://webwlsong.github.io/categories/go/%E5%86%85%E5%AD%98/"},{"name":"堆栈","slug":"go/内存/堆栈","permalink":"https://webwlsong.github.io/categories/go/%E5%86%85%E5%AD%98/%E5%A0%86%E6%A0%88/"},{"name":"mono","slug":"mono","permalink":"https://webwlsong.github.io/categories/mono/"},{"name":"nginx","slug":"nginx","permalink":"https://webwlsong.github.io/categories/nginx/"},{"name":"golang","slug":"go/golang","permalink":"https://webwlsong.github.io/categories/go/golang/"}],"tags":[{"name":"OpenResty","slug":"OpenResty","permalink":"https://webwlsong.github.io/tags/OpenResty/"},{"name":"lua","slug":"lua","permalink":"https://webwlsong.github.io/tags/lua/"},{"name":"cdn","slug":"cdn","permalink":"https://webwlsong.github.io/tags/cdn/"},{"name":"阿里云","slug":"阿里云","permalink":"https://webwlsong.github.io/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"},{"name":"网易云","slug":"网易云","permalink":"https://webwlsong.github.io/tags/%E7%BD%91%E6%98%93%E4%BA%91/"},{"name":"七牛云","slug":"七牛云","permalink":"https://webwlsong.github.io/tags/%E4%B8%83%E7%89%9B%E4%BA%91/"},{"name":"segmantfault","slug":"segmantfault","permalink":"https://webwlsong.github.io/tags/segmantfault/"},{"name":"唯品会","slug":"唯品会","permalink":"https://webwlsong.github.io/tags/%E5%94%AF%E5%93%81%E4%BC%9A/"},{"name":"Electron","slug":"Electron","permalink":"https://webwlsong.github.io/tags/Electron/"},{"name":"C++","slug":"C","permalink":"https://webwlsong.github.io/tags/C/"},{"name":"QT","slug":"QT","permalink":"https://webwlsong.github.io/tags/QT/"},{"name":"Flutter","slug":"Flutter","permalink":"https://webwlsong.github.io/tags/Flutter/"},{"name":"PHP","slug":"PHP","permalink":"https://webwlsong.github.io/tags/PHP/"},{"name":"超时","slug":"超时","permalink":"https://webwlsong.github.io/tags/%E8%B6%85%E6%97%B6/"},{"name":"小程序","slug":"小程序","permalink":"https://webwlsong.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"python","slug":"python","permalink":"https://webwlsong.github.io/tags/python/"},{"name":"pyenv","slug":"pyenv","permalink":"https://webwlsong.github.io/tags/pyenv/"},{"name":"树莓派","slug":"树莓派","permalink":"https://webwlsong.github.io/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"},{"name":"go","slug":"go","permalink":"https://webwlsong.github.io/tags/go/"},{"name":"c","slug":"c","permalink":"https://webwlsong.github.io/tags/c/"},{"name":"c++","slug":"c","permalink":"https://webwlsong.github.io/tags/c/"},{"name":"内存","slug":"内存","permalink":"https://webwlsong.github.io/tags/%E5%86%85%E5%AD%98/"},{"name":"堆栈","slug":"堆栈","permalink":"https://webwlsong.github.io/tags/%E5%A0%86%E6%A0%88/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://webwlsong.github.io/tags/ubuntu/"},{"name":"linux","slug":"linux","permalink":"https://webwlsong.github.io/tags/linux/"},{"name":"frp","slug":"frp","permalink":"https://webwlsong.github.io/tags/frp/"},{"name":"内网穿透","slug":"内网穿透","permalink":"https://webwlsong.github.io/tags/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"},{"name":"hexo","slug":"hexo","permalink":"https://webwlsong.github.io/tags/hexo/"},{"name":"pure","slug":"pure","permalink":"https://webwlsong.github.io/tags/pure/"},{"name":"docker","slug":"docker","permalink":"https://webwlsong.github.io/tags/docker/"},{"name":"gitlab","slug":"gitlab","permalink":"https://webwlsong.github.io/tags/gitlab/"},{"name":"php","slug":"php","permalink":"https://webwlsong.github.io/tags/php/"},{"name":"php-jit","slug":"php-jit","permalink":"https://webwlsong.github.io/tags/php-jit/"},{"name":"operator","slug":"operator","permalink":"https://webwlsong.github.io/tags/operator/"},{"name":"mono","slug":"mono","permalink":"https://webwlsong.github.io/tags/mono/"},{"name":"fira","slug":"fira","permalink":"https://webwlsong.github.io/tags/fira/"},{"name":"code","slug":"code","permalink":"https://webwlsong.github.io/tags/code/"},{"name":"nginx","slug":"nginx","permalink":"https://webwlsong.github.io/tags/nginx/"},{"name":"phpstrom","slug":"phpstrom","permalink":"https://webwlsong.github.io/tags/phpstrom/"},{"name":"jetbrains","slug":"jetbrains","permalink":"https://webwlsong.github.io/tags/jetbrains/"},{"name":"nodejs","slug":"nodejs","permalink":"https://webwlsong.github.io/tags/nodejs/"},{"name":"性能测试","slug":"性能测试","permalink":"https://webwlsong.github.io/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"},{"name":"delve","slug":"delve","permalink":"https://webwlsong.github.io/tags/delve/"},{"name":"mongo","slug":"mongo","permalink":"https://webwlsong.github.io/tags/mongo/"},{"name":"php-mongo","slug":"php-mongo","permalink":"https://webwlsong.github.io/tags/php-mongo/"},{"name":"swoole","slug":"swoole","permalink":"https://webwlsong.github.io/tags/swoole/"},{"name":"tcp","slug":"tcp","permalink":"https://webwlsong.github.io/tags/tcp/"},{"name":"golang","slug":"golang","permalink":"https://webwlsong.github.io/tags/golang/"},{"name":"架构","slug":"架构","permalink":"https://webwlsong.github.io/tags/%E6%9E%B6%E6%9E%84/"}]}