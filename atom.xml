<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>webwlsong</title>
  
  <subtitle>无</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://webwlsong.github.io/"/>
  <updated>2021-03-10T09:19:13.382Z</updated>
  <id>https://webwlsong.github.io/</id>
  
  <author>
    <name>webwlsong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>OpenResty安装和lua-resty-http的使用</title>
    <link href="https://webwlsong.github.io/2021/03/10/2021/2021-02/2021-03-10/"/>
    <id>https://webwlsong.github.io/2021/03/10/2021/2021-02/2021-03-10/</id>
    <published>2021-03-09T16:00:00.000Z</published>
    <updated>2021-03-10T09:19:13.382Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装openresty"><a class="markdownIt-Anchor" href="#安装openresty"></a> 安装OpenResty</h1><ol><li><p>加入源</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum-config-manager --add-repo https:&#x2F;&#x2F;openresty.org&#x2F;package&#x2F;centos&#x2F;openresty.repo</span><br></pre></td></tr></table></figure></li><li><p>安装openresty</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install openresty</span><br></pre></td></tr></table></figure><ol start="3"><li>安装LuaRock<br /><a href="https://luarocks.org/">luarock</a> 是一个lua modules包安装工具</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ wget https:&#x2F;&#x2F;luarocks.org&#x2F;releases&#x2F;luarocks-3.5.0.tar.gz</span><br><span class="line">$ tar zxpf luarocks-3.5.0.tar.gz</span><br><span class="line">$ cd luarocks-3.5.0</span><br><span class="line">$ .&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;openresty&#x2F;luajit --with-lua&#x3D;&#x2F;usr&#x2F;local&#x2F;openresty&#x2F;luajit --lua-suffix&#x3D;jit --with-lua-include&#x3D;&#x2F;usr&#x2F;local&#x2F;openresty&#x2F;luajit&#x2F;include&#x2F;luajit-2.1 &amp;&amp; make &amp;&amp; sudo make install</span><br><span class="line">$ sudo luarocks install luasocket</span><br><span class="line">$ lua</span><br><span class="line">Lua 5.3.5 Copyright (C) 1994-2018 Lua.org, PUC-Rio</span><br><span class="line">&gt; require &quot;socket</span><br></pre></td></tr></table></figure><ol start="4"><li><p>OpenResty中使用lua-resty-http完成HTTP请求</p><p>lua-resty-http是OpenResty版本的Http客户端，基于cosocket实现<br />开源地址：<a href="https://github.com/ledgetech/lua-resty-http">https://github.com/ledgetech/lua-resty-http</a></p><p>4.1：安装依赖</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">luarocks install lua-resty-http</span><br></pre></td></tr></table></figure><p>代码示例<br />GET请求：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">local http &#x3D; require(&#39;resty.http&#39;)</span><br><span class="line">local httpc &#x3D; http.new()</span><br><span class="line">local res, err &#x3D; httpc:request_uri(&#39;http:&#x2F;&#x2F;localhost&#x2F;hello&#39;, &#123;</span><br><span class="line">    keepalive_timeout &#x3D; 2000 -- 毫秒</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">if not res or res.status then</span><br><span class="line">    ngx.log(ngx.ERR, &quot;request error#&quot;, err)</span><br><span class="line">    return</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">ngx.log(ngx.ERR, &quot;request status#&quot;, res.status)</span><br><span class="line">ngx.say(res.body)</span><br></pre></td></tr></table></figure><p>POST请求：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">local http &#x3D; require &quot;resty.http&quot;</span><br><span class="line">local httpc &#x3D; http.new()</span><br><span class="line">local res, err &#x3D; httpc:request_uri(&quot;http:&#x2F;&#x2F;localhost&#x2F;hello&quot;, &#123;</span><br><span class="line">  method &#x3D; &quot;POST&quot;,</span><br><span class="line">  body &#x3D; &quot;a&#x3D;1&amp;b&#x3D;2&quot;,</span><br><span class="line">  headers &#x3D; &#123;</span><br><span class="line">    [&quot;Content-Type&quot;] &#x3D; &quot;application&#x2F;x-www-form-urlencoded&quot;,</span><br><span class="line">  &#125;,</span><br><span class="line">  keepalive_timeout &#x3D; 60,</span><br><span class="line">  keepalive_pool &#x3D; 10</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">if not res or res.status then</span><br><span class="line">    ngx.log(ngx.ERR, &quot;request error#&quot;, err)</span><br><span class="line">    return</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">ngx.log(ngx.ERR, &quot;request status#&quot;, res.status)</span><br><span class="line">ngx.say(res.body)</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;安装openresty&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#安装openresty&quot;&gt;&lt;/a&gt; 安装OpenResty&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;加入源&lt;/p&gt;
 &lt;figure class=&quot;highlight p
      
    
    </summary>
    
    
      <category term="OpenResty" scheme="https://webwlsong.github.io/tags/OpenResty/"/>
    
      <category term="lua" scheme="https://webwlsong.github.io/tags/lua/"/>
    
  </entry>
  
  <entry>
    <title>腾讯cdn命中率低，用户感觉cdn慢，从HTTP响应头看各家CDN缓存技术</title>
    <link href="https://webwlsong.github.io/2021/02/26/2021/2021-02/2021-02-26/"/>
    <id>https://webwlsong.github.io/2021/02/26/2021/2021-02/2021-02-26/</id>
    <published>2021-02-25T16:00:00.000Z</published>
    <updated>2021-02-26T08:57:27.900Z</updated>
    
    <content type="html"><![CDATA[<h2 id="腾讯云cdn命中率低是什么原因呢"><a class="markdownIt-Anchor" href="#腾讯云cdn命中率低是什么原因呢"></a> 腾讯云cdn命中率低是什么原因呢？</h2><p>命中率低可能由以下原因造成：</p><ul><li>缓存配置问题，如缓存时间较短。</li><li>HTTP Header 导致无法缓存，请检查源站 Cache-Control 或 Expires 的设置。</li><li>源站类型问题，可缓存的内容少。</li><li>网站访问量低，过期时间短，命中的文件少，导致频繁回源。</li></ul><p>文章来源：<a href="https://cloud.tencent.com/document/product/228/11207">https://cloud.tencent.com/document/product/228/11207</a></p><h2 id="用户感觉-cdn-访问慢-主要说腾讯cdn"><a class="markdownIt-Anchor" href="#用户感觉-cdn-访问慢-主要说腾讯cdn"></a> 用户感觉 CDN 访问慢？ 主要说腾讯cdn</h2><p>大文件关注下载速度，小文件关注延时。首先得到用户访问慢的 URL，通过测速网站判断是否访问慢（推荐工具： <a href="https://www.17ce.com/">17ce</a> ）。<br />如果测速确实慢，且源站属于自有源，请 提交工单 我们将协助用户排查源站机器负载和带宽是否受限。<br />如何判断用户访问是否命中 CDN Cache？<br />查看访问回包头部的 X-Cache-Lookup 信息，若同时返回多个 X-Cache-Lookup 属正常情况，当返回 Cache Hit/Hit From MemCache/Hit From Disktank 时表示命中 CDN Cache：</p><ul><li><p>X-Cache-Lookup:Hit From MemCache 表示命中 CDN 节点的内存。</p></li><li><p>X-Cache-Lookup:Hit From Disktank 表示命中 CDN 节点的磁盘。</p></li><li><p>x-cache 是指从浏览器从那个地方缓存网页</p></li><li><p>x-cache-lookup项指专门查看代理服务器中是否有某个网页缓存  缓存的话，返回：hit，没有换成返回MISS</p></li></ul><p>文章来源：<br />X-Cache 和 X-Cache-Lookup headers 的解释<br />中文：<a href="https://blog.haohtml.com/archives/4783">https://blog.haohtml.com/archives/4783</a><br />英文：<a href="https://anothersysadmin.wordpress.com/2008/04/22/x-cache-and-x-cache-lookup-headers-explained/">https://anothersysadmin.wordpress.com/2008/04/22/x-cache-and-x-cache-lookup-headers-explained/</a></p><p>文章来源：<a href="https://cloud.tencent.com/document/product/228/11207">https://cloud.tencent.com/document/product/228/11207</a></p><h2 id="从http响应头看各家cdn缓存技术"><a class="markdownIt-Anchor" href="#从http响应头看各家cdn缓存技术"></a> 从HTTP响应头看各家CDN缓存技术</h2><p>由于国内各家电信运营商互联互通的壁垒，CDN作为互联网用户加速的最后一公里，扮演了很重要的角色。</p><p>在各家公司大谈的异地多活容灾上也承担了用户分流的重任，看看各家用的东西，结合一些网上的公开资料，也能管中窥豹。</p><p>传统的国内CDN厂家有：帝联，网宿，蓝汛，快网等<br />新兴的互联网公司有自家产品对外输出型和创业公司细分型：BAT都有此产品，还有七牛，又拍，微软azure等<br />美国龙头：Akamai，美国市场大哥，Apple用的也是这个，但Apple的在线服务这么烂，真怀疑是不是Apple把Akamai带坑里了。</p><p>本文只展示响应头，有兴趣自己深挖。</p><p>##淘宝</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">server:Tengine</span><br><span class="line">status:200</span><br><span class="line">timing-allow-origin:*</span><br><span class="line">via:cache15.l2et15-1[0,200-0,H], cache35.l2et15-1[0,0], cache3.cn286[0,200-0,H], cache8.cn286[11,0]</span><br><span class="line">x-cache:HIT TCP_MEM_HIT dirn:20:727080716</span><br><span class="line">x-swift-cachetime:31535998</span><br><span class="line">x-swift-savetime:Fri, 19 Aug 2016 02:55:13 GMT</span><br></pre></td></tr></table></figure><p>不用说，淘宝用的是自家阿里CDN， 走Tengine， 返回的响应很友好，甚至告诉你是从内存命中的。<br />x-swift指明了使用了的具体热点缓存技术。<br />关于阿里云CDN,有很多公开介绍，例如：<br />文章一：阿里云CDN技术演进之路 <a href="http://www.slideshare.net/jos">http://www.slideshare.net/jos</a>…<br />文章二：研究下淘宝的swift热点缓存迁移的事</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">via:cache46.l2et2[0,200-0,H], cache60.l2et2[0,0], cache7.cn286[0,200-0,H], cache8.cn286[3,0]</span><br><span class="line">x-cache:HIT TCP_HIT dirn:11:60349972</span><br><span class="line">x-swift-cachetime:31535950</span><br><span class="line">x-swift-savetime:Tue, 28 Jun 2016 04:04:29 GMT</span><br></pre></td></tr></table></figure><p>根据阿里云官网解释：<br />若：X-Cache:HIT TCP_MEM_HIT 表示命中缓存<br />若：X-Cache:MISS TCP_MISS 则表示未命中缓存</p><p>##微信<br />腾讯CDN节点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Server:Qnginx&#x2F;1.1.1</span><br><span class="line">X-Cache-Lookup:Hit From Disktank</span><br><span class="line">X-NWS-LOG-UUID:406395d0-7cb8-4630-99cf-8208d04e7750</span><br></pre></td></tr></table></figure><p>很明显，这里告诉大家CDN命中了磁盘缓存上的数据。<br />一些网上资料查到的解释：<br />X-Cache-Lookup:Hit From MemCache 表示命中CDN节点的内存<br />X-Cache-Lookup:Hit From Disktank 表示命中CDN节点的磁盘<br />X-Cache-Lookup:Hit From Upstream 表示没有命中CDN</p><p>腾讯CDN起步可能会晚一点，Qcon上一个公开资料：<br />CDN架构技术之道<br />腾讯还与小米合作，在硬盘版小米路由上推出了一个插件，叫腾讯会员兑换，本质上就是利用小米路由用户上的硬盘存储一部分内容，上传给需要用的用户，由腾讯计算收益，盘活了家里闲时的网络资源。</p><p>x-cache 是指从浏览器从那个地方缓存网页<br />x-cache-lookup项指专门查看代理服务器中是否有某个网页缓存  缓存的话，返回：hit，没有换成返回MISS</p><h2 id="网易云音乐"><a class="markdownIt-Anchor" href="#网易云音乐"></a> 网易云音乐</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Server:nginx</span><br><span class="line">X-Via:1.1 ngdianxin90:9 (Cdn Cache Server V2.0)</span><br></pre></td></tr></table></figure><p>网易太低调，最近也开始搞网易云产品了，但基本查不到什么公开资料，从响应头看似乎就是直接用的nginx。</p><h2 id="新浪微博"><a class="markdownIt-Anchor" href="#新浪微博"></a> 新浪微博</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: image&#x2F;gif</span><br><span class="line">SINA-LB: aGEuNDEuZzEuc2h4LmxiLnNpbmFub2RlLmNvbQ&#x3D;&#x3D;</span><br><span class="line">SINA-TS: ZGFkYzk4Y2UgMCAwIDAgOCAwCg&#x3D;&#x3D;</span><br><span class="line">Via: http&#x2F;1.1 ctc.ningbo.ha2ts4.70 (ApacheTrafficServer&#x2F;4.2.1.1 [cRs f ])</span><br><span class="line">X-Via-CDN: f&#x3D;Edge,s&#x3D;ctc.ningbo.ha2ts4.70,c&#x3D;115.231.82.33</span><br><span class="line">Age: 1</span><br><span class="line">X-Via: 1.1 zjjhdx33:3 (Cdn Cache Server V2.0), 1.1 tzhoudxin37:5 (Cdn Cache Server V2.0)</span><br><span class="line">Connection: keep-alive</span><br></pre></td></tr></table></figure><p>这个返回了Cdn Cache Server V2.0，有多家公司都返回了这个，不知道这是个啥玩意，是不是个开源通用产品呢？Squid Varnish Nginx？</p><h2 id="segmantfault"><a class="markdownIt-Anchor" href="#segmantfault"></a> segmantfault：</h2><p>命中</p><figure class="highlight plain"><figcaption><span>M.ctn-zj-lna-204</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x-cache:HIT(R) from ctn-zj-lna-204</span><br><span class="line">x-request-id:c239b9ae8ec9f83030bbdfaabcfa8fb4</span><br><span class="line">x-source:U&#x2F;200, G&#x2F;200</span><br></pre></td></tr></table></figure><p>缓存MISS</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">via:T.101195.N.1, T.101163.R.1, V.mix-hz-fdi-163, M.ctn-zj-lna-200</span><br><span class="line">x-cache:MISS(S) from ctn-zj-lna-200</span><br><span class="line">x-request-id:724565e217e01e9f60e9f1b74aecedb3</span><br><span class="line">在ctn-zj-lna上缓存没有命中,这个ctn-zj是个CDN集群么？</span><br></pre></td></tr></table></figure><p>##七牛</p><p>访问该图片:<a href="http://7xt44n.com2.z0.glb.qin">http://7xt44n.com2.z0.glb.qin</a>…<br />Response header返回：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X-Log:mc.g;IO:1&#x2F;304</span><br><span class="line">X-Qiniu-Zone:0</span><br><span class="line">X-Reqid:90oAABxCoNMaw2wU</span><br><span class="line">X-Via:1.1 dxxz44:2 (Cdn Cache Server V2.0), 1.1 ngdianxin42:6 (Cdn Cache Server V2.0)</span><br></pre></td></tr></table></figure><p>用的就是自家产品。</p><h2 id="唯品会"><a class="markdownIt-Anchor" href="#唯品会"></a> 唯品会</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Server:vipshop&#x2F;Vbib</span><br><span class="line">Transfer-Encoding:chunked</span><br><span class="line">Vip-Cache:HIT</span><br><span class="line">x-amz-delete-marker:false</span><br><span class="line">X-Via:1.1 xxxz53:0 (Cdn Cache Server V2.0), 1.1 zhdx34:6 (Cdn Cache Server V2.0)</span><br></pre></td></tr></table></figure><p>看Server的响应头，似乎也应该是自家搭建的CDN,显示了命中与否。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;腾讯云cdn命中率低是什么原因呢&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#腾讯云cdn命中率低是什么原因呢&quot;&gt;&lt;/a&gt; 腾讯云cdn命中率低是什么原因呢？&lt;/h2&gt;
&lt;p&gt;命中率低可能由以下原因造成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;缓
      
    
    </summary>
    
    
      <category term="cdn" scheme="https://webwlsong.github.io/tags/cdn/"/>
    
      <category term="阿里云" scheme="https://webwlsong.github.io/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"/>
    
      <category term="网易云" scheme="https://webwlsong.github.io/tags/%E7%BD%91%E6%98%93%E4%BA%91/"/>
    
      <category term="七牛云" scheme="https://webwlsong.github.io/tags/%E4%B8%83%E7%89%9B%E4%BA%91/"/>
    
      <category term="segmantfault" scheme="https://webwlsong.github.io/tags/segmantfault/"/>
    
      <category term="唯品会" scheme="https://webwlsong.github.io/tags/%E5%94%AF%E5%93%81%E4%BC%9A/"/>
    
  </entry>
  
  <entry>
    <title>桌面程序技术选型大厂使用技术以及优劣对比</title>
    <link href="https://webwlsong.github.io/2021/02/06/2021/2021-02/2021-02-06/"/>
    <id>https://webwlsong.github.io/2021/02/06/2021/2021-02/2021-02-06/</id>
    <published>2021-02-05T16:00:00.000Z</published>
    <updated>2021-02-07T02:41:06.834Z</updated>
    
    <content type="html"><![CDATA[<ol><li>大厂客户端使用技术</li></ol><table><thead><tr><th style="text-align:center">软件</th><th style="text-align:center">客户端</th><th style="text-align:center">语言</th></tr></thead><tbody><tr><td style="text-align:center">微信/qq/百度网盘</td><td style="text-align:center">Windows</td><td style="text-align:center">c++  duilib</td></tr><tr><td style="text-align:center">wps</td><td style="text-align:center">Windows</td><td style="text-align:center">c++ qt</td></tr><tr><td style="text-align:center">酷狗 qq音乐 网易云音乐 阿里旺旺</td><td style="text-align:center">Windows</td><td style="text-align:center">c++ libcef</td></tr><tr><td style="text-align:center">讯雷</td><td style="text-align:center">Windows</td><td style="text-align:center">Electron</td></tr><tr><td style="text-align:center">钉钉/微小宝/微信web开发工具</td><td style="text-align:center">Mac</td><td style="text-align:center">nw.js</td></tr></tbody></table><p>钉钉<br /><img src="https://i.loli.net/2021/02/07/namQwWYGBlgiLX6.png" alt="" /></p><p>微小宝<br /><img src="https://i.loli.net/2021/02/07/ZfIJXYTeAyOpsV4.png" alt="" /></p><ol><li><p>做全端技术选型 C++ ,QT ,Winform ,Wpf,Electron,Flutter,C#(WebWindow+Blazor),Tauri</p><ul><li>Tauri 带后期观察 -话说可以取代Electron替代产品<br />代码仓库：<a href="https://github.com/tauri-apps/tauri">https://github.com/tauri-apps/tauri</a></li><li>Blazor 是一个使用 .NET 生成交互式客户端 Web UI 的框架：<ul><li>使用 C# 代替 JavaScript 来创建信息丰富的交互式 UI。</li><li>共享使用 .NET 编写的服务器端和客户端应用逻辑。</li><li>将 UI 呈现为 HTML 和 CSS，以支持众多浏览器，其中包括移动浏览器。</li><li>与新式托管平台（如 Docker）集成。</li></ul></li><li>使用 .NET 进行客户端 Web 开发可提供以下优势：<ul><li>使用 C# 代替 JavaScript 来编写代码。</li><li>利用现有的 .NET 库生态系统。</li><li>在服务器和客户端之间共享应用逻辑。</li><li>受益于 .NET 的性能、可靠性和安全性。</li><li>在 Windows、Linux 和 macOS 上使用 Visual Studio 保持高效工作。</li><li>以一组稳定、功能丰富且易用的通用语言、框架和工具为基础来进行生成。<br />其他的自行搜索引擎查看文章</li></ul></li></ul></li><li><p>优缺点对比</p><ul><li><p><a href="https://nwjs.org.cn/">NW.js</a> 和 <a href="http://electron.org.cn">Electron</a> 优缺点分析对比<br />通过前面的案例意识使用情况来看<br />优点：</p><ul><li>开源的核心扩展比较容易，目前是基于 node 6.x，加之现在 gyp 已经非常人性化了，使得c++ 和 js 搞基非常容易。</li><li>界面定制性强，原则上只要是Web能做的他都能做。</li><li>是目前最廉价的跨平台技术方案，HTML+JS 有大量的前端技术人员储备，而且有海量的现存web UI 库。大多都很靠谱。</li><li>相对其他跨平台方案（如 QT GTK+ 等），更稳定，bug少， 毕竟只要浏览器外壳跑起来了，里面的问题不会太多 ，当然我也遇到过一些暗坑。</li><li>方便热更新。下载覆盖完事。当然这是所有脚本共有的优点。</li></ul><p>缺点：</p><ul><li>卡，启动慢，这可能是webkit的锅。毕竟一个浏览器要支持的功能确实有点多。</li><li>除了主进程 你可能还需要启动一些辅助进程来完成工作。而每当你新开一个进程，起步价就是一个nodejs的内存开销！</li><li>丢帧，这个最严重，可我已习惯了native 的丝滑. mac下感觉还可以 win下有点够呛。</li><li>打出来的包太大。（很显然，即便是一个空包，也至少包含了一个浏览器的体积</li></ul></li></ul></li><li><p>根据2021年1月<a href="https://www.tiobe.com/tiobe-index/">语言排行榜</a></p></li></ol><p><img src="https://i.loli.net/2021/02/07/MX9tfBbaVwndEKO.png" alt="20210207103809.png" /><br /><img src="https://i.loli.net/2021/02/07/cqSVPrvDzIX9A5B.png" alt="" /></p><ol start="5"><li><p>我的技术选型<br />如果2021年开始做全端的互联网产品，目前阶段我的个人优先选择Flutter &gt; Electron<br />C#(WebWindow+Blazor)后劲十足，后期观察tauri根据作者的排的计划来看，估计要到2021年底才出一个bete版本，<a href="https://tauri.studio/en/">官网</a> 2022年以后才能做一个稳定版本<br />根据不同产品需求技术选型时不一样，仁者见仁，智者见智。如果：如果做汽车类的一些产品或者工业级级别客户端优先去考虑QT,毕竟库还是很丰富。<br />我的技术选型一般从一下几个方面去考虑：</p><ul><li>技术生命周期，活跃性</li><li>在某些行业库是否比较丰富</li><li>根据团队的技术特点和项目的时间规划周期</li></ul></li><li><p><em>参考资料</em></p><ul><li>nw.js和Electron 优劣对比<ul><li><a href="https://blog.csdn.net/small_tu/article/details/86606819">https://blog.csdn.net/small_tu/article/details/86606819</a></li><li><a href="https://www.jianshu.com/p/7c66ee28ce51">https://www.jianshu.com/p/7c66ee28ce51</a></li></ul></li><li><a href="http://Asp.net">Asp.net</a> Core Blazor<ul><li><a href="https://www.jianshu.com/p/7c66ee28ce51">https://www.jianshu.com/p/7c66ee28ce51</a></li><li><a href="https://docs.microsoft.com/zh-cn/aspnet/core/blazor/?view=aspnetcore-5.0">https://docs.microsoft.com/zh-cn/aspnet/core/blazor/?view=aspnetcore-5.0</a></li></ul></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;大厂客户端使用技术&lt;/li&gt;
&lt;/ol&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;软件&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;客户端&lt;/th&gt;
&lt;th style=&quot;t
      
    
    </summary>
    
    
      <category term="Electron" scheme="https://webwlsong.github.io/tags/Electron/"/>
    
      <category term="C++" scheme="https://webwlsong.github.io/tags/C/"/>
    
      <category term="QT" scheme="https://webwlsong.github.io/tags/QT/"/>
    
      <category term="Flutter" scheme="https://webwlsong.github.io/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>php Maximum execution time of 0 seconds exceeded</title>
    <link href="https://webwlsong.github.io/2021/02/03/2021/2021-02/2021-02-03/"/>
    <id>https://webwlsong.github.io/2021/02/03/2021/2021-02/2021-02-03/</id>
    <published>2021-02-02T16:00:00.000Z</published>
    <updated>2021-02-07T02:29:44.171Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>#0 [1]ErrorException in PDOConnection.php line 1240<br />Maximum execution time of 0 seconds exceeded</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> ; Maximum amount of time each script may spend parsing request data. It&#x27;s a      good</span><br><span class="line"> ; idea to limit this time on productions servers in order to eliminate unex     pectedly</span><br><span class="line">; long running scripts.</span><br><span class="line">; Note: This directive is hardcoded to -1 for the CLI SAPI</span><br><span class="line">; Default Value: -1 (Unlimited)</span><br><span class="line">; Development Value: 60 (60 seconds)</span><br><span class="line">; Production Value: 60 (60 seconds)</span><br><span class="line">; http://php.net/max-input-time</span><br><span class="line"> ;默认是60  每个页面接受数据最大的时间 </span><br><span class="line">max_input_time = 60</span><br></pre></td></tr></table></figure><p>这种情况可能用两种情况下产生：</p><ol><li>内存超限制，可以通过在循环里面添加sleep(5),放置同时间内存占满的，每个循环内部使用ob_frush 释放内存</li><li>页面请求时间超时<br />修改请求数据超时max_input_time 设置大些</li></ol><p>解决：PHP脚本执行超时</p><p>max_execution_time = 600  //最大执行时间<br />max_input_time = 600 //页面请求接受数据最大时间<br />memory_limit= 128M    //脚本内存限制</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;#0 [1]ErrorException in PDOConnection.php line 1240&lt;br /&gt;
Maximum execution time of 0 seconds exceeded&lt;/p&gt;
&lt;/blockquote&gt;
&lt;fi
      
    
    </summary>
    
    
      <category term="PHP" scheme="https://webwlsong.github.io/tags/PHP/"/>
    
      <category term="超时" scheme="https://webwlsong.github.io/tags/%E8%B6%85%E6%97%B6/"/>
    
  </entry>
  
  <entry>
    <title>图解微信第三方开放平台流程图</title>
    <link href="https://webwlsong.github.io/2020/09/24/2020/2020-09/2020-09-24/"/>
    <id>https://webwlsong.github.io/2020/09/24/2020/2020-09/2020-09-24/</id>
    <published>2020-09-23T16:00:00.000Z</published>
    <updated>2020-09-23T16:29:55.964Z</updated>
    
    <content type="html"><![CDATA[<h2 id="微信第三方开放平台流程图"><a class="markdownIt-Anchor" href="#微信第三方开放平台流程图"></a> 微信第三方开放平台流程图</h2><p><img src="https://i.loli.net/2020/09/24/Ost8Vo36UifjFIB.png" alt="微信第三方开放平台流程图" /></p><h2 id="授权流程技术说明"><a class="markdownIt-Anchor" href="#授权流程技术说明"></a> 授权流程技术说明</h2><p>小程序或者公众号授权给第三方平台的技术实现流程比较简单，如下图所示：<br />第三方服务商构建授权链接放置自己的网站，用户点击后，弹出授权页面<br /><img src="https://i.loli.net/2020/09/24/T58OrHo1KNWqGfX.jpg" alt="0" /><br />账号管理员扫码，选择需要授权的账号，进行授权。<br /><img src="https://i.loli.net/2020/09/24/S4Qcg5xRPEhq6rJ.jpg" alt="0 -1-" /><br />用户可自定义选择权限集进行授权<br /><img src="https://i.loli.net/2020/09/24/EXnS63idLP8ekJt.png" alt="g-sXXzWmk61svoMroJyjjEcJY8qb0JFTNsh22E44EbHUD3ciJfmtXBtPZ73hezHt" /></p><p>下面对其进行详细介绍：</p><ul><li><p>步骤 1：第三方平台方获取预授权码（pre_auth_code）<br /><a href="https://developers.weixin.qq.com/doc/oplatform/Third-party_Platforms/api/pre_auth_code.html">详见</a></p></li><li><p>步骤 2：引入用户进入授权页</p></li></ul><p>第三方平台方可以在自己的网站中放置“微信公众号授权”或者“小程序授权”的入口，或生成授权链接放置在移动网页中，引导公众号和小程序管理员进入授权页。</p><p>方式一：授权注册页面扫码授权</p><p>授权页网址为：<br /><a href="https://mp.weixin.qq.com/cgi-bin/componentloginpage?component_appid=xxxx&amp;pre_auth_code=xxxxx&amp;redirect_uri=xxxx&amp;auth_type=xxx%E3%80%82">https://mp.weixin.qq.com/cgi-bin/componentloginpage?component_appid=xxxx&amp;pre_auth_code=xxxxx&amp;redirect_uri=xxxx&amp;auth_type=xxx。</a></p><p><em>参考文献:</em></p><ul><li><em>微信第三方平台授权流程技术说明<br /><a href="https://developers.weixin.qq.com/doc/oplatform/Third-party_Platforms/Third_party_platform_appid.html">https://developers.weixin.qq.com/doc/oplatform/Third-party_Platforms/Third_party_platform_appid.html</a></em></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;微信第三方开放平台流程图&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#微信第三方开放平台流程图&quot;&gt;&lt;/a&gt; 微信第三方开放平台流程图&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/09/24/Os
      
    
    </summary>
    
      <category term="小程序" scheme="https://webwlsong.github.io/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="小程序" scheme="https://webwlsong.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>pyenv的安装和简单使用（git、pyenv、pyenv-virtualenv）</title>
    <link href="https://webwlsong.github.io/2020/09/18/2020/2020-09/2020-09-18/"/>
    <id>https://webwlsong.github.io/2020/09/18/2020/2020-09/2020-09-18/</id>
    <published>2020-09-17T16:00:00.000Z</published>
    <updated>2020-09-18T01:05:00.102Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p><img src="https://i.loli.net/2020/09/18/7eGfMl86NDjUkFd.jpg" alt="python生态工具" /></p><h1 id="python工作环境管理"><a class="markdownIt-Anchor" href="#python工作环境管理"></a> Python工作环境管理</h1><p>Python 2和Python 3之间存在着较大的差异，并且，由于各种原因导致了Python 2和Python 3的长期 共存。在实际工作过程中，我们可能会同时用到Python 2和Python 3，因此，需要经常在Python 2和 Python 3之间进行来回切换。此外，如果你是喜欢尝鲜的人，那么，你很有可能在Python新版本出来 的时候立即下载Python的版本，试验Python的特性。</p><p>在Python世界里，除了需要对Python的版本进行管理以外，还需要对不同的软件包进行管理。大部分 情况下，对于开源的库我们使用版本即可。但是，有时候可能需要对相同的Python版本，在不同的 项目中使用不同版本的软件包。</p><p>在这一节里，我们将介绍两个工具，即pyenv和virtualenv。前者用于管理不同的Python版本，后者用 于管理不同的工作环境。有了这两个工具，Python相关的版本问题将不再是问题。</p><h2 id="1-情景问题"><a class="markdownIt-Anchor" href="#1-情景问题"></a> 1、情景问题</h2><ol><li>Python解释器版本混乱, 2和3差别巨大, 而且细分版本也不尽相同, 难以选择和管理.</li><li>不同Linux发行版自带Python不同, 如ubuntu16自带2.7和3.5版本, 其中系统许多组件依赖于自带解释器, 一旦删除或者更改都可能会造成系统出问题.</li><li>不同的Python解释器软件包管理也是问题, 如pip和ipython等必备包组件, 而且在项目开发中如何保证不同的包环境互不干扰也是一个问题.</li><li></li></ol><p>那么有没有一个终极的解决办法能在管理不同解释器版本的同时控制不同的包环境呢? 有的, 就是pyenv.</p><h2 id="2-使用pyenv管理不同的python版本"><a class="markdownIt-Anchor" href="#2-使用pyenv管理不同的python版本"></a> 2、使用pyenv管理不同的Python版本</h2><p>安装不同的Python版本并不是一件容易的事情，在不同的Python版本之间来回切换更加困难，而且， 多版本并存非常容易互相干扰。因此，我们需要一个名为pyenv的工具。pyenv是一个Python版本管理 工具，它能够进行全局的Python版本切换，也可以为单个项目提供对应的Python版本。使用pyenv以 后，可以在服务器上安装多个不同的Python版本，也可以安装不同的Python实现。不同Python版本之 间的切换也非常简单。接下来我们就一起看一下pyenv的安装和使用。</p><h2 id="pyenv是什么-能干什么"><a class="markdownIt-Anchor" href="#pyenv是什么-能干什么"></a> pyenv是什么? 能干什么?</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pyenv是一个forked自ruby社区的简单、低调、遵循UNIX哲</span><br><span class="line"></span><br><span class="line">学的Python环境管理工具, 它可以轻松切换全局解释器版本, </span><br><span class="line"></span><br><span class="line">同时结合vitualenv插件可以方便的管理对应的包源.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们知道, 在terminal中输入一个命令比如‘ls’时, shell会从当前环境的PATH中的各个目录里看是不是有ls这个可执行文件, 如果找到就执行, 否则就会报‘command no found’ 的错误, 同理, 只要控制PATH变量就能够做到python版本的切换, pyenv通过在PATH头部插入shims路径来实现对python版本的控制.</p><p>pyenv和流行的pipenv、virtualenv的关系</p><p>pipenv是requests 作者 Kenneth Reitz大神写的一个python虚拟环境管理工具, 结合了pip和virtualenv的功能, 侧重点还是在包环境管理上, 使用思路是先创建一个指定python版本的环境, 然后在此环境上安装相应的包, 好评不错, 看到很多大牛都在推荐.</p><p>pipenv是requests 作者 Kenneth Reitz大神写的一个python虚拟环境管理工具, 结合了pip和virtualenv的功能, 侧重点还是在包环境管理上, 使用思路是先创建一个指定python版本的环境, 然后在此环境上安装相应的包, 好评不错, 看到很多大牛都在推荐.</p><p>pyenv相对来说知名度就差很多了, 不过也很稳定, 这三个环境管理工具我都用过, 我个人更喜欢pyenv, 理由如下:</p><ol><li>相对于其他两个工具, pyenv更侧重在python 解释器版本管理上, 比包管理更大一个层级, 使用pyenv我可以方便的下载指定版本的python解释器, pypy, anaconda等, 可以随时自由的在shell环境中本地、全局切换python解释器</li><li>开发的时候不需要限定某个版本的虚拟环境, 只需要在部署的时候用pyenv指定某个版本就好了</li><li>pyenv切换解释器版本的时候, pip和ipython以及对应的包环境都是一起切换的, 所以如果你要同时运行ipython2.x和ipython3.x多个解释器验证一些代码时就很方便</li><li>pyenv也可以创建好指定的虚拟环境, 但不需要指定具体目录, 自由度更高, 使用也简单</li></ol><h2 id="4-简单使用"><a class="markdownIt-Anchor" href="#4-简单使用"></a> 4、简单使用</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前版本</span></span><br><span class="line">pyenv version</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有版本</span></span><br><span class="line">pyenv versions</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有可安装的版本</span></span><br><span class="line">pyenv install --list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装指定版本</span></span><br><span class="line">pyenv install 3.6.5</span><br><span class="line"><span class="comment"># 安装新版本后rehash一下</span></span><br><span class="line">pyenv <span class="built_in">rehash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除指定版本</span></span><br><span class="line">pyenv uninstall 3.5.2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定全局版本</span></span><br><span class="line">pyenv global 3.6.5</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定多个全局版本, 3版本优先</span></span><br><span class="line">pyenv global 3.6.5 2.7.14</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实际上当你切换版本后, 相应的pip和包仓库都是会自动切换过去的</span></span><br></pre></td></tr></table></figure><h2 id="一-pyenv安装"><a class="markdownIt-Anchor" href="#一-pyenv安装"></a> 一、pyenv安装</h2><ol><li>安装 pyenv</li></ol><p>说明：本文的所有安装都严格遵守官方文档，与官方文档完全保持一致。</p><p>git 地址：<a href="https://github.com/pyenv/pyenv">https://github.com/pyenv/pyenv</a></p><p>在你的终端中执行如下命令，安全无毒，请放心食用：</p><p>首先把项目克隆下来，放在家目录下的隐藏文件夹中：.pyenv</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;pyenv&#x2F;pyenv.git ~&#x2F;.pyenv</span><br></pre></td></tr></table></figure><p>然后配置变量</p><p>如果你使用 bash，就依次执行如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export PYENV_ROOT=&quot;$HOME/.pyenv&quot;&#x27;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export PATH=&quot;$PYENV_ROOT/bin:$PATH&quot;&#x27;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&#x27;if command -v pyenv 1&gt;/dev/null 2&gt;&amp;1; then\n eval &quot;$(pyenv init -)&quot;\nfi&#x27;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果你使用 zsh，就依次执行如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export PYENV_ROOT=&quot;$HOME/.pyenv&quot;&#x27;</span> &gt;&gt; ~/.zshrc</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export PATH=&quot;$PYENV_ROOT/bin:$PATH&quot;&#x27;</span> &gt;&gt; ~/.zshrc</span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&#x27;if command -v pyenv 1&gt;/dev/null 2&gt;&amp;1; then\n eval &quot;$(pyenv init -)&quot;\nfi&#x27;</span> &gt;&gt; ~/.zshrc</span><br></pre></td></tr></table></figure><p>echo 命令的含义是：将引号中内容写入某文件中<br />请注意，以上的三条 echo 命令的最后一条长长的命令，请你保证它引号中的内容处于 ~/.bashrc 或者 ~/.zshrc 的最底部。<br />因为在 pyenv 初始化期间会操作 path 环境变量，导致不可预测的行为。<br />查看文件的底部内容，可以使用 tail 命令，用法：tail ~/.bashrc 或者 tail ~/.zshrc，编辑文件可以使用 vim 或者 vscode</p><p>最后，在使用 pyenv 之前，重新初始化 shell 环境，执行如下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exec</span> <span class="variable">$SHELL</span> 或者 <span class="built_in">source</span> </span><br></pre></td></tr></table></figure><p>不执行该命令也是完全可以的，你可以关闭当前的终端窗口，重新启动一个就可以了。</p><p>此时，你已经完成了 pyenv 的安装了，你使用可以它的全部命令了，但是我建议你先别急着用，一口气装完 pyenv 的一个插件，那就是 pyenv-virtualenv</p><ol start="2"><li>安装 pyenv-virtualenv</li></ol><p>virtualenv本身是一个独立的项目，用以隔离不同项目的工作环境。例如，用户lmx希望在项目A中使用 Flask 0.8这个版本，与此同时，又想在项目B中使用Flask 0.9这个版本。如果我们全局安装Flask，必然 无法满足用户的需求。这个时候，我们就可以使用virtualenv。</p><p>读者需要注意pyenv和virtualenv的区别。pyenv用以管理不同的Python版本，例如，你的系统工作时 使用Python 2.7.13，学习时使用Python 3.6.0。virtualenv用以隔离项目的工作环境，例如，项目A和 项目B都是使用Python 2.7.13，但是，项目A需要使用Flask 0.8版本，项目B需要使用Flask 0.9版本。我 们只要组合pyenv和virtualenv这两个工具，就能够构造Python和第三方库的任意版本组合，拥有很好 的灵活性，也避免了项目之间的相互干扰。</p><p>virtualenv本身是一个独立的工具，用户可以不使用pyenv而单独使用virtualenv。但是，如果你使用了 pyenv，就需要安装pyenv-virtualenv插件，而不是通过virtualenv软件使用virtualenv的功能。</p><p>git 地址：<a href="https://github.com/pyenv/pyenv-virtualenv">https://github.com/pyenv/pyenv-virtualenv</a></p><p>(1) 把插件克隆在刚才已经安装完毕的 pyenv 的 plugins 文件夹中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/pyenv/pyenv-virtualenv.git $(pyenv root)/plugins/pyenv-virtualenv</span><br></pre></td></tr></table></figure><p>(2) 然后配置环境变量<br />如果你使用 bash，就执行如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;eval &quot;$(pyenv virtualenv-init -)&quot;&#x27;</span> &gt;&gt; ~/.bashrc</span><br></pre></td></tr></table></figure><p>如果你使用 zsh，就执行如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;eval &quot;$(pyenv virtualenv-init -)&quot;&#x27;</span> &gt;&gt; ~/.zshrc</span><br></pre></td></tr></table></figure><p>(3) 最后，在使用 pyenv 之前，重新初始化 shell 环境，执行如下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exec</span> <span class="variable">$SHELL</span></span><br></pre></td></tr></table></figure><p>不执行该命令也是完全可以的，你可以关闭当前的终端窗口，重新启动一个就可以了。</p><p>至此，pyenv就安装完成了，我们可以通过下面的命令验证pyenv是否正确安装并获取pyenv的帮助信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">pyenv --<span class="built_in">help</span></span><br><span class="line">Usage: pyenv &lt;<span class="built_in">command</span>&gt; [&lt;args&gt;]</span><br><span class="line"></span><br><span class="line">Some useful pyenv commands are:</span><br><span class="line">   --version   Display the version of pyenv</span><br><span class="line">   activate    Activate virtual environment</span><br><span class="line">   commands    List all available pyenv commands</span><br><span class="line">   deactivate   Deactivate virtual environment</span><br><span class="line">   <span class="built_in">exec</span>        Run an executable with the selected Python version</span><br><span class="line">   global      Set or show the global Python version(s)</span><br><span class="line">   <span class="built_in">help</span>        Display <span class="built_in">help</span> <span class="keyword">for</span> a <span class="built_in">command</span></span><br><span class="line">   hooks       List hook scripts <span class="keyword">for</span> a given pyenv <span class="built_in">command</span></span><br><span class="line">   init        Configure the shell environment <span class="keyword">for</span> pyenv</span><br><span class="line">   install     Install a Python version using python-build</span><br><span class="line">   <span class="built_in">local</span>       Set or show the <span class="built_in">local</span> application-specific Python version(s)</span><br><span class="line">   prefix      Display prefix <span class="keyword">for</span> a Python version</span><br><span class="line">   <span class="built_in">rehash</span>      Rehash pyenv shims (run this after installing executables)</span><br><span class="line">   root        Display the root directory <span class="built_in">where</span> versions and shims are kept</span><br><span class="line">   shell       Set or show the shell-specific Python version</span><br><span class="line">   shims       List existing pyenv shims</span><br><span class="line">   uninstall   Uninstall a specific Python version</span><br><span class="line">   version     Show the current Python version(s) and its origin</span><br><span class="line">   version-file   Detect the file that sets the current pyenv version</span><br><span class="line">   version-name   Show the current Python version</span><br><span class="line">   version-origin   Explain how the current Python version is <span class="built_in">set</span></span><br><span class="line">   versions    List all Python versions available to pyenv</span><br><span class="line">   virtualenv   Create a Python virtualenv using the pyenv-virtualenv plugin</span><br><span class="line">   virtualenv-delete   Uninstall a specific Python virtualenv</span><br><span class="line">   virtualenv-init   Configure the shell environment <span class="keyword">for</span> pyenv-virtualenv</span><br><span class="line">   virtualenv-prefix   Display real_prefix <span class="keyword">for</span> a Python virtualenv version</span><br><span class="line">   virtualenvs   List all Python virtualenvs found <span class="keyword">in</span> `<span class="variable">$PYENV_ROOT</span>/versions/*<span class="string">&#x27;.</span></span><br><span class="line"><span class="string">   whence      List all Python versions that contain the given executable</span></span><br><span class="line"><span class="string">   which       Display the full path to an executable</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">See `pyenv help &lt;command&gt;&#x27;</span> <span class="keyword">for</span> information on a specific <span class="built_in">command</span>.</span><br><span class="line">For full documentation, see: https://github.com/pyenv/pyenv<span class="comment">#readme</span></span><br></pre></td></tr></table></figure><h2 id="二-使用-pyenv"><a class="markdownIt-Anchor" href="#二-使用-pyenv"></a> 二、使用 pyenv</h2><p>此处仅仅展示 pyenv 和 virtualenv 的日常用法</p><p>1、检查安装是否正确<br />检查 pyenv 的版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@python ~]<span class="comment"># pyenv version</span></span><br><span class="line">(<span class="built_in">set</span> by /root/.pyenv/version)</span><br><span class="line">查看 pyenv 已经管理了哪些 python 版本</span><br><span class="line">[root@python ~]<span class="comment">#pyenv versions</span></span><br><span class="line">* system (<span class="built_in">set</span> by /root/.pyenv/version)</span><br></pre></td></tr></table></figure><p>如果你看到了正常的版本信息，就说明可以了，如果看到了类似于 command not found 之类的，就说明安装失败了。</p><p>我们通过pyenv的install命令，可以查看pyenv当前支持哪些Python版本，如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@python ~]<span class="comment"># pyenv install --list </span></span><br><span class="line">Available versions:</span><br><span class="line">2.1.3</span><br><span class="line">……省略部分信息</span><br><span class="line">3.8.0</span><br><span class="line">3.8-dev</span><br><span class="line">3.8.1</span><br><span class="line">3.9-dev</span><br><span class="line">……省略部分信息</span><br><span class="line">anaconda3-2018.12</span><br><span class="line">anaconda3-2019.03</span><br><span class="line">anaconda3-2019.07</span><br><span class="line">anaconda3-2019.10</span><br><span class="line">……省略部分信息</span><br><span class="line">[root@python ~]<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>2、pyenv切换python版本<br />由于pyenv可以安装的Python版本列表非常长，所以，这里进行了省略。读者可以在自己电脑上安装 pyenv，然后执行pyenv install --list命令进行查看。可以看到，pyenv不但可以安装不同的Python版 本，而且还可以安装不同的Python实现，也可以安装版本的Python用以学习。</p><p>查看当前系统中包含的Python版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@python ~]<span class="comment"># pyenv versions </span></span><br><span class="line">* system (<span class="built_in">set</span> by /root/.pyenv/version)</span><br><span class="line">使用pyenv安装不同的Python版本：</span><br><span class="line">[root@python ~]<span class="comment">#pyenv install -v 3.8.1  </span></span><br><span class="line">[root@python ~]<span class="comment">#pyenv install -v 2.7.13 </span></span><br></pre></td></tr></table></figure><p>再次查看当前系统中包含的Python版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@python ~]<span class="comment"># pyenv versions</span></span><br><span class="line">* system (<span class="built_in">set</span> by /root/.pyenv/version)</span><br><span class="line">  2.7.13</span><br><span class="line">  3.8.1</span><br></pre></td></tr></table></figure><ol start="3"><li>切换前为3.8.1</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#切换当前为3.8.1</span></span><br><span class="line">[root@python ~]<span class="comment"># python</span></span><br><span class="line">Python 3.8.1 (default, Apr 20 2020, 15:00:10) </span><br><span class="line">[GCC 4.8.5 20150623 (Red Hat 4.8.5-39)] on linux</span><br><span class="line">Type <span class="string">&quot;help&quot;</span>, <span class="string">&quot;copyright&quot;</span>, <span class="string">&quot;credits&quot;</span> or <span class="string">&quot;license&quot;</span> <span class="keyword">for</span> more informatio</span><br></pre></td></tr></table></figure><ol start="4"><li>切换为2.7.13</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@python ~]<span class="comment"># pyenv  global 2.7.13 </span></span><br><span class="line">[root@python ~]<span class="comment"># python</span></span><br><span class="line">Python 2.7.13 (default, Apr 20 2020, 15:04:15) </span><br><span class="line">[GCC 4.8.5 20150623 (Red Hat 4.8.5-39)] on linux2</span><br><span class="line">Type <span class="string">&quot;help&quot;</span>, <span class="string">&quot;copyright&quot;</span>, <span class="string">&quot;credits&quot;</span> or <span class="string">&quot;license&quot;</span> <span class="keyword">for</span> more information.</span><br></pre></td></tr></table></figure><p>使用pyenv以后，可以快速切换Python的版本。切换Python版本以后，与版本相关的依赖也会一起切 换。因此，我们不用担心不同的版本在系统中是否会相互干扰。例如，切换Python版本以后，相应的 pip也会跟着切换，所以不用担心自己使用的pip版本和Python版本不匹配的问题，如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@python ~]<span class="comment"># pyenv  global 3.8.1</span></span><br><span class="line">[root@python ~]<span class="comment"># pip --version</span></span><br><span class="line">pip 19.2.3 from /root/.pyenv/versions/3.8.1/lib/python3.8/site-packages/pip (python 3.8)</span><br><span class="line">如果想要删除Python版本，使用uninstall命令即可。如下所示：</span><br><span class="line">[root@python ~]<span class="comment"># pyenv uninstall 2.7.10</span></span><br></pre></td></tr></table></figure><h2 id="三-pyenv-virtualenv的使用"><a class="markdownIt-Anchor" href="#三-pyenv-virtualenv的使用"></a> 三、pyenv-virtualenv的使用</h2><p>有了pyenv-virtualenv以后，我们可以为同一个Python解释器，创建多个不同的工作环境。例如，我们 新建两个工作环境：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@python ~]<span class="comment"># pyenv virtualenv 3.8.1 first_project </span></span><br><span class="line">[root@python ~]<span class="comment"># pyenv virtualenv 3.8.1 second_projec</span></span><br><span class="line">可以使用virtualenvs子命令查看工作环境</span><br><span class="line">[root@python ~]<span class="comment"># pyenv virtualenvs</span></span><br><span class="line">  3.8.1/envs/first_project (created from /root/.pyenv/versions/3.8.1)</span><br><span class="line">  3.8.1/envs/second_projec (created from /root/.pyenv/versions/3.8.1)</span><br><span class="line">  first_project (created from /root/.pyenv/versions/3.8.1)</span><br><span class="line">  second_projec (created from /root/.pyenv/versions/3.8.1)</span><br></pre></td></tr></table></figure><p>创建完工作环境以后，可以通过activate和deactivate子命令进入或退出一个工作环境。进入工作环境 以后，左边的提示符会显示你当前所在的工作环境，以免因为环境太多导致操作错误。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">(first_project) </span><br><span class="line">[root@python ~]<span class="comment"># pip install flask==1.1.1 </span></span><br><span class="line">Looking <span class="keyword">in</span> indexes: https://pypi.doubanio.com/simple</span><br><span class="line">Collecting flask==1.1.1</span><br><span class="line">  Downloading https://pypi.doubanio.com/packages/9b/93/628509b8d5dc749656a9641f4caf13540e2cdec85276964ff8f43bbb1d3b/Flask-1.1.1-py2.py3-none-any.whl (94kB)</span><br><span class="line">     |███▌                            | 10kB 28.0MB/s eta 0:00:</span><br><span class="line">     |███████                         | 20kB 1.8MB/s eta 0:00:0</span><br><span class="line">     |██████████▍                     | 30kB 2.7MB/s eta 0:00:0</span><br><span class="line">     |█████████████▉                  | 40kB 1.8MB/s eta 0:00:0</span><br><span class="line">     |█████████████████▍              | 51kB 1.3MB/s eta 0:00:0</span><br><span class="line">     |████████████████████▉           | 61kB 1.5MB/s eta 0:00:0</span><br><span class="line">     |████████████████████████▎       | 71kB 1.4MB/s eta 0:00:0</span><br><span class="line">     |███████████████████████████▊    | 81kB 1.3MB/s eta 0:00:0</span><br><span class="line">     |███████████████████████████████▏| 92kB 1.4MB/s eta 0:00:0</span><br><span class="line">     |████████████████████████████████| 102kB 1.6MB/s </span><br><span class="line">Collecting itsdangerous&gt;=0.24 (from flask==1.1.1)</span><br><span class="line">(first_project) [root@python ~]<span class="comment"># pyenv deactivate</span></span><br><span class="line"><span class="comment">## 退出first_project环境</span></span><br><span class="line">[root@python ~]<span class="comment"># </span></span><br></pre></td></tr></table></figure><p>接下来，我们看一下在不同的工作环境安装不同的Flask版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@python ~]<span class="comment"># pyenv activate first_project </span></span><br><span class="line"><span class="comment">##切换工作环境</span></span><br><span class="line">(first_project) [root@python ~]<span class="comment"># pip install flask==1.1.1 </span></span><br><span class="line"><span class="comment">##安装1.1.1的flask</span></span><br><span class="line">(first_project) [root@python ~]<span class="comment"># pyenv deactivate </span></span><br><span class="line"><span class="comment">##退出目前工作环境</span></span><br><span class="line">[root@python ~]<span class="comment">#</span></span><br><span class="line"></span><br><span class="line">[root@python ~]<span class="comment"># pyenv activate second_projec</span></span><br><span class="line"><span class="comment">##切换工作环境</span></span><br><span class="line">(second_project) [root@python ~]<span class="comment"># pip install flask==0.10.1</span></span><br><span class="line"><span class="comment">##安装0.10.1的flask</span></span><br><span class="line">(second_project) [root@python ~]<span class="comment"># pyenv deactivate </span></span><br><span class="line"><span class="comment">##退出目前工作环境</span></span><br><span class="line">[root@python ~]<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>查看一下两个工作环境源目录<br />pyenv的安装和简单使用（git、pyenv、pyenv-virtualenv）</p><p>如果想要删除虚拟环境，则使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(first_project)</span><br><span class="line"> [root@python ~]<span class="comment"># pyenv virtualenv-delete first_project </span></span><br></pre></td></tr></table></figure><p>使用pyenv和python-virtualenv插件，我们就能够自由地在不同的版本之间进行切换，相比管理Python 版本，不但节省了时间，也避免了工作过程中的相互干扰。</p><h2 id="四-更新-pyenv"><a class="markdownIt-Anchor" href="#四-更新-pyenv"></a> 四、更新 pyenv</h2><p>由于我们是 git 克隆的，所以更新非常简单</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/.pyenv` 或者 `<span class="built_in">cd</span> $(pyenv root)`</span><br><span class="line"> `git pull</span><br></pre></td></tr></table></figure><h2 id="五-卸载-pyenv"><a class="markdownIt-Anchor" href="#五-卸载-pyenv"></a> 五、卸载 pyenv</h2><p>由于 pyenv 把一切都放在 ~/.pyenv 下了，所以卸载很方便，两个步骤就行了</p><p>首先你需要删除环境变量</p><p>然后你需要执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf ~/.pyenv` 或者 `rm -rf $(pyenv root)</span><br></pre></td></tr></table></figure><p><em>载录文献:</em></p><ul><li><em>pyenv的安装和简单使用（git、pyenv、pyenv-virtualenv）<br /><a href="https://blog.51cto.com/14320361/2488888">https://blog.51cto.com/14320361/2488888</a></em></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/09/18/7eGfMl86NDjUkFd.jpg&quot; alt=&quot;python生态工具&quot; /&gt;&lt;/p&gt;
&lt;h1 id=&quot;python工作环境管理&quot;&gt;&lt;a class=&quot;markdow
      
    
    </summary>
    
      <category term="python" scheme="https://webwlsong.github.io/categories/python/"/>
    
    
      <category term="python" scheme="https://webwlsong.github.io/tags/python/"/>
    
      <category term="pyenv" scheme="https://webwlsong.github.io/tags/pyenv/"/>
    
  </entry>
  
  <entry>
    <title>Mac用串口(ttl)连接树莓派3b+以及串口调试</title>
    <link href="https://webwlsong.github.io/2020/09/07/2020/2020-09/2020-09-07/"/>
    <id>https://webwlsong.github.io/2020/09/07/2020/2020-09/2020-09-07/</id>
    <published>2020-09-06T16:00:00.000Z</published>
    <updated>2021-02-07T02:06:57.298Z</updated>
    
    <content type="html"><![CDATA[<h2 id="macosx用串口ttl连接树莓派"><a class="markdownIt-Anchor" href="#macosx用串口ttl连接树莓派"></a> MacOSX用串口(TTL)连接树莓派</h2><ul><li>树莓派在没有显示使用时，可以使用usb串口转ttl进行连接。<br />USB转ttl线 CP2102下载对应的驱动<br />USB转TTL 驱动下载地址：<a href="http://pan.baidu.com/s/1mgCFd9m">http://pan.baidu.com/s/1mgCFd9m</a><br />安装完成后重启系统，插入 USB to TTL 线可查询串口设备。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ls /dev/tty.usbserial*   <span class="comment">#在Mac是这个，去查看。插拔usb能够看到对应的设备</span></span><br><span class="line">/dev/tty.usbserial</span><br></pre></td></tr></table></figure><p>USB转TTL线</p><p><img src="https://static01.imgkr.com/temp/9473f3e37795437a8308ee3958e229b2.jpg" alt="usbtoTTL" /></p><p>树莓派3b+引脚图<br /><img src="https://static01.imgkr.com/temp/db5437d45d5246f79854c980d739768a.jpeg" alt="树莓派3b+引脚图" /></p><p>USB to TTL 线与树莓派针脚对应关系为：<br />GND -&gt; GND<br />RXD -&gt; GPIO 14(TXD)<br />TXD -&gt; GPIO 15(RXD)<br />VCC -&gt; 悬空 (切记, 不要乱接)</p><p>注意: 一定按照上面的对应关系，不要接成一样的。</p><h3 id="配置minicom参数"><a class="markdownIt-Anchor" href="#配置minicom参数"></a> 配置minicom参数</h3><p>运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo minicom -s</span><br></pre></td></tr></table></figure><p>进入minicom界面</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">┌─────[configuration]──────┐</span><br><span class="line">│ Filenames and paths      │</span><br><span class="line">│ File transfer protocols  │</span><br><span class="line">│ Serial port setup        │</span><br><span class="line">│ Modem and dialing        │</span><br><span class="line">│ Screen and keyboard      │</span><br><span class="line">│ Save setup as dfl        │</span><br><span class="line">│ Save setup as..          │</span><br><span class="line">│ Exit                     │</span><br><span class="line">│ Exit from Minicom        │</span><br><span class="line">└──────────────────────────┘</span><br></pre></td></tr></table></figure><p>使用上下键选择Serial port setup，回车。此时停留在change which setting?  通过A,B,C,D选项设置对应的参数设置例如下</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">┌───────────────────────────────────────────────────────────────────────┐</span><br><span class="line">│ A -    Serial Device      : /dev/modem                                │</span><br><span class="line">│ B - Lockfile Location     : /usr/local/Cellar/minicom/2.7.1/var       │</span><br><span class="line">│ C -   Callin Program      :                                           │</span><br><span class="line">│ D -  Callout Program      :                                           │</span><br><span class="line">│ E -    Bps/Par/Bits       : 115200 8N1                                │</span><br><span class="line">│ F - Hardware Flow Control : Yes                                       │</span><br><span class="line">│ G - Software Flow Control : No                                        │</span><br><span class="line">│                                                                       │</span><br><span class="line">│    Change which setting?                                              │</span><br><span class="line">└───────────────────────────────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure><h3 id="配置选项目录"><a class="markdownIt-Anchor" href="#配置选项目录"></a> 配置选项目录</h3><p>选择&quot;Filenames and paths&quot;</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">┌───────────────────────────────────────────────────────────────────────┐</span><br><span class="line">│ A - Download directory :    /home/wonux                               │</span><br><span class="line">│ B - Upload directory   :   /tmp                                       │</span><br><span class="line">│ C - Script directory   :    /root/minicom                             │</span><br><span class="line">│ D - Script program     : runscript   or /bin/bash                     │</span><br><span class="line">│ E - Kermit program     :                                              │</span><br><span class="line">│ F - Logging options                                                   │</span><br><span class="line">│                                                                       │</span><br><span class="line">│    Change which setting?                                              │</span><br><span class="line">└───────────────────────────────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure><h3 id="常用配置总结"><a class="markdownIt-Anchor" href="#常用配置总结"></a> 常用配置总结：</h3><ul><li>选择Serial port setup<br />配置选项如下：</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A - Serial Device : /dev/modem </span><br><span class="line">E - Bps/Par/Bits : 115200 8N1 </span><br><span class="line">F - Hardware Flow Control : No </span><br><span class="line">G - Software Flow Control : No </span><br></pre></td></tr></table></figure><ul><li>选择Filenames and paths<br />配置其中的如下配置项：</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C - Script directory : /root/minicom</span><br><span class="line">D - Script program : /bin/bash</span><br></pre></td></tr></table></figure><p>C:脚本文件的存放位置: <C-a> g运行脚本时的路径 。<br />D:选择脚本程序: 默认runscript,也可以选择bash脚本格式。</p><h2 id="树莓派3b添加散热外壳"><a class="markdownIt-Anchor" href="#树莓派3b添加散热外壳"></a> 树莓派3b+添加散热外壳</h2><p>在某宝上买了一个外壳。<br /><img src="https://static01.imgkr.com/temp/b635a9a9fcba4327b55363d4f8232a9b.png" alt="树莓派3b+外壳" /></p><p>线与树莓派针脚对应关系为：<br />红色-&gt; +5v<br />黑色-&gt; GND #地线<br /><img src="https://static01.imgkr.com/temp/c5ba5a0d84e6411897a48f2cdad169f8.jpeg" alt="成品" /></p><h2 id="mac串口调试工具minicom"><a class="markdownIt-Anchor" href="#mac串口调试工具minicom"></a> mac串口调试工具minicom</h2><p>我们使用常用的串口工具，如：minicom, screen 使用 115200 进行连接。它们的安装也非常的方便：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 minicom</span></span><br><span class="line">$ brew install minicom</span><br><span class="line"><span class="comment"># 进行配置后再进行连接</span></span><br><span class="line">$ minicom -s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 screen</span></span><br><span class="line">$ brew install screen</span><br><span class="line"><span class="comment"># 进行连接</span></span><br><span class="line">screen /dev/tty.usbserial 115200</span><br></pre></td></tr></table></figure><p>连接后我们输入默认的账号和密码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">用户名：pi</span><br><span class="line">密码：raspberry</span><br></pre></td></tr></table></figure><h2 id="树莓派连接上网设置"><a class="markdownIt-Anchor" href="#树莓派连接上网设置"></a> 树莓派连接上网设置</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev</span><br><span class="line">update_config=1</span><br><span class="line">country=GB</span><br><span class="line"></span><br><span class="line">network=&#123;</span><br><span class="line">        ssid=<span class="string">&quot;######&quot;</span>  <span class="comment">#wifi 名称</span></span><br><span class="line">        psk=<span class="string">&quot;*******&quot;</span>   <span class="comment">#wifi密码</span></span><br><span class="line">        proto=RSN            </span><br><span class="line">        key_mgmt=WPA-PSK    <span class="comment">#加密方式  </span></span><br><span class="line">        pairwise=CCMP</span><br><span class="line">        auth_alg=OPEN</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">network=&#123;</span><br><span class="line">        ssid=<span class="string">&quot;#######&quot;</span></span><br><span class="line">        psk=<span class="string">&quot;**********&quot;</span></span><br><span class="line">        proto=RSN</span><br><span class="line">        key_mgmt=WPA-PSK</span><br><span class="line">        pairwise=CCMP</span><br><span class="line">        auth_alg=OPEN</span><br><span class="line">&#125;</span><br><span class="line">~</span><br></pre></td></tr></table></figure><p>完整呈现：<br /><img src="https://static01.imgkr.com/temp/be442bb87f88482abceddaaac939a18e.gif" alt="呈现raspberry" /></p><p><em>参考资料：</em></p><ul><li><em><a href="https://blog.csdn.net/sikinzen/article/details/5451758">https://blog.csdn.net/sikinzen/article/details/5451758</a></em></li><li><em>minicom中文手册</em></li><li><em><a href="https://www.jianshu.com/p/71191dd41eab">https://www.jianshu.com/p/71191dd41eab</a></em></li><li><em><a href="https://www.jianshu.com/p/40412eb7f567">https://www.jianshu.com/p/40412eb7f567</a></em></li><li><em><a href="https://www.jianshu.com/p/b132508a0fa3?from=singlemessage">https://www.jianshu.com/p/b132508a0fa3?from=singlemessage</a></em></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;macosx用串口ttl连接树莓派&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#macosx用串口ttl连接树莓派&quot;&gt;&lt;/a&gt; MacOSX用串口(TTL)连接树莓派&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;树莓派在没有显示使用时，可以使用usb
      
    
    </summary>
    
    
      <category term="树莓派" scheme="https://webwlsong.github.io/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
  </entry>
  
  <entry>
    <title>图解Golang的内存管理分配</title>
    <link href="https://webwlsong.github.io/2020/09/03/2020/2020-09/2020-09-02/"/>
    <id>https://webwlsong.github.io/2020/09/03/2020/2020-09/2020-09-02/</id>
    <published>2020-09-02T16:00:00.000Z</published>
    <updated>2020-09-18T01:05:32.948Z</updated>
    
    <content type="html"><![CDATA[<p>go主要有以下五种内存存储区(c/c++也是一样)：</p><p><img src="https://webwlsong-1301722012.cos.ap-shanghai.myqcloud.com/mweb/2020/09/03/1599064164048.jpg" alt="内存分配" /></p><h2 id="go的内存分配核心思想"><a class="markdownIt-Anchor" href="#go的内存分配核心思想"></a> Go的内存分配核心思想</h2><p>Go是内置运行时的编程语言(<code>runtime</code>)，像这种内置运行时的编程语言通常会抛弃传统的内存分配方式，改为自己管理。这样可以完成类似预分配、内存池等操作，以避开系统调用带来的性能问题，防止每次分配内存都需要系统调用。</p><p>用户线程的调度以及生命周期管理都是用户层面，Go语言自己实现的，不借助OS系统调用，减少系统资源消耗。</p><p>Go的内存分配的核心思想可以分为以下几点：</p><ul><li>每次从操作系统申请一大块儿的内存，由Go来对这块儿内存做分配，减少系统调用</li><li>内存分配算法采用Google的<a href="http://goog-perftools.sourceforge.net/doc/tcmalloc.html">TCMalloc</a>算法。算法比较复杂，究其原理可自行查阅。其核心思想就是把内存切分的非常的细小，分为多级管理，以降低锁的粒度。</li><li>回收对象内存时，并没有将其真正释放掉，只是放回预先分配的大块内存中，以便复用。只有内存闲置过多的时候，才会尝试归还部分内存给操作系统，降低整体开销</li></ul><p>业界比较出名的内存分配器有Google的<code>tcmalloc</code>和Facebook的<code>jemalloc</code>。二者在避免内存碎片和性能上均比glic有比较大的优势，在多线程环境中效果更明显。</p><h2 id="程序在内存中的分布"><a class="markdownIt-Anchor" href="#程序在内存中的分布"></a> 程序在内存中的分布</h2><p><img src="https://webwlsong-1301722012.cos.ap-shanghai.myqcloud.com/mweb/2020/09/03/cheng-xu-nei-cun-yun-xing.jpg" alt="程序内存运行" /></p><ul><li>代码段(<code>.text</code>)，也称文本段(Text Segment)，存放着程序的机器码和只读数据，可执行指令就是从这里取得的。如果可能，系统会安排好相同程序的多个运行实体共享这些实例代码。这个段在内存中一般被标记为只读，任何对该区的写操作都会导致段错误（Segmentation Fault）</li><li>数据段，包括已初始化的数据段(<code>.data</code>)和未初始化的数据段（<code>.bss</code>），前者用来存放保存全局的和静态的已初始化变量，后者用来保存全局的和静态的未初始化变量。数据段在编译时分配</li><li>堆栈段分为堆和栈：<ul><li><p>堆（<code>Heap</code>）：用来存储程序运行时分配的变量。堆的大小并不固定，可动态扩张或缩减。其分配由malloc()、new()等这类实时内存分配函数来实现。当进程调用malloc等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用free          等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减） 堆的内存释放由应用程序去控制，通常一个new()就要对应一个delete()，如果程序员没有释放掉，那么在程序结束后操作系统会自动回收。</p></li><li><p>栈（<code>Stack</code>）是一种用来存储函数调用时的临时信息的结构，如函数调用所传递的参数、函数的返回地址、函数的局部变量等。 在程序运行时由编译器在需要的时候分配，在不需要的时候自动清除。</p><p>栈的特性: 最后一个放入栈中的物体总是被最先拿出来，这个特性通常称为先进后出(FILO)队列。`<br />栈的基本操作： PUSH操作：向栈中添加数据，称为压栈，数据将放置在栈顶； POP操作：POP操作相反，在栈顶部移去一个元素，并将栈的大小减一，称为弹栈。</p></li></ul></li></ul><h2 id="堆和栈的区别"><a class="markdownIt-Anchor" href="#堆和栈的区别"></a> 堆和栈的区别</h2><ul><li><p>分配和管理方式不同 ：</p><ul><li>堆是动态分配的，其空间的分配和释放都由程序员控制。</li><li>栈由编译器自动管理。栈有两种分配方式：静态分配和动态分配。<ul><li>静态分配由编译器完成，比如局部变量的分配。</li><li>动态分配由alloca()函数进行分配，但是栈的动态分配和堆是不同的，它的动态分配是由编译器进行释放，无须手工控制。</li></ul></li></ul></li><li><p>产生碎片不同</p><ul><li>对堆来说，频繁的new/delete或者malloc/free势必会造成内存空间的不连续，造成大量的碎片，使程序效率降低。</li><li>对栈而言，则不存在碎片问题，因为栈是先进后出的队列，永远不可能有一个内存块从栈中间弹出。</li></ul></li><li><p>生长方向不同</p><ul><li>堆是向着内存地址增加的方向增长的，从内存的低地址向高地址方向增长。</li><li>栈的生长方向与之相反，是向着内存地址减小的方向增长，由内存的高地址向低地址方向增长。</li></ul></li></ul><p>了解更多：</p><ol><li><a href="https://zhuanlan.zhihu.com/p/29216091">图解TCMalloc</a> goole内存分配器</li><li><a href="https://blog.csdn.net/cxsydjn/article/details/79487805">C/C++程序的5种内存存储区及示意</a></li></ol><p><em>参考文献:</em></p><ul><li><em>程序在内存中的分布 <a href="https://www.cnblogs.com/Lynn-Zhang/p/5449199.html">https://www.cnblogs.com/Lynn-Zhang/p/5449199.html</a></em></li><li><em>从内存分配开始 <a href="https://mp.weixin.qq.com/s/EyWKFRu1xryoHY386QUcuA">https://mp.weixin.qq.com/s/EyWKFRu1xryoHY386QUcuA</a></em></li><li><em>译文：Go 内存分配器可视化指南 <a href="https://www.linuxzen.com/go-memory-allocator-visual-guide.html">https://www.linuxzen.com/go-memory-allocator-visual-guide.html</a></em></li><li><em>图解Go语言内存分配 <a href="https://juejin.im/post/5c888a79e51d456ed11955a8">https://juejin.im/post/5c888a79e51d456ed11955a8</a></em></li><li><em>Golang源码探索(三) GC的实现原理 <a href="https://www.cnblogs.com/zkweb/p/7880099.html">https://www.cnblogs.com/zkweb/p/7880099.html</a></em></li><li><em>《Go专家编程》Go 内存管理 <a href="https://my.oschina.net/renhc/blog/2236782?spm=a2c4e.10696291.0.0.a8e219a4hLvsZx">https://my.oschina.net/renhc/blog/2236782?spm=a2c4e.10696291.0.0.a8e219a4hLvsZx</a></em></li><li><em>雨痕&lt;&lt;Go源码解析&gt;&gt;<br />go内存分配(英文) <a href="https://andrestc.com/post/go-memory-allocation-pt1/">https://andrestc.com/post/go-memory-allocation-pt1/</a></em></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;go主要有以下五种内存存储区(c/c++也是一样)：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://webwlsong-1301722012.cos.ap-shanghai.myqcloud.com/mweb/2020/09/03/1599064164048.jpg&quot; 
      
    
    </summary>
    
      <category term="go" scheme="https://webwlsong.github.io/categories/go/"/>
    
      <category term="内存" scheme="https://webwlsong.github.io/categories/go/%E5%86%85%E5%AD%98/"/>
    
      <category term="堆栈" scheme="https://webwlsong.github.io/categories/go/%E5%86%85%E5%AD%98/%E5%A0%86%E6%A0%88/"/>
    
    
      <category term="go" scheme="https://webwlsong.github.io/tags/go/"/>
    
      <category term="c" scheme="https://webwlsong.github.io/tags/c/"/>
    
      <category term="c++" scheme="https://webwlsong.github.io/tags/c/"/>
    
      <category term="内存" scheme="https://webwlsong.github.io/tags/%E5%86%85%E5%AD%98/"/>
    
      <category term="堆栈" scheme="https://webwlsong.github.io/tags/%E5%A0%86%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>DIY服务器搭建，内网穿透搭建</title>
    <link href="https://webwlsong.github.io/2020/08/31/2020/2020-08/2020-08-31/"/>
    <id>https://webwlsong.github.io/2020/08/31/2020/2020-08/2020-08-31/</id>
    <published>2020-08-31T09:09:00.000Z</published>
    <updated>2020-09-09T11:54:57.405Z</updated>
    
    <content type="html"><![CDATA[<p>起初一直在用云服务器来搭自用服务器，为什么还要用自建一个服务器？</p><ul><li>云服务价格偏高性</li><li>性能达不到要求</li><li>IT人爱折腾，生命不止，学习不止</li></ul><h2 id="服务器选择"><a class="markdownIt-Anchor" href="#服务器选择"></a> 服务器选择</h2><ul><li>耗电量小</li><li>性价比高</li><li>噪声小(几乎没有噪声)<br />考虑过台式工作站服务器，NAS，最终选择mini电脑当自用服务器。</li></ul><h2 id="制作u盘linux启动盘"><a class="markdownIt-Anchor" href="#制作u盘linux启动盘"></a> 制作U盘Linux启动盘</h2><p>推荐使用工具rufus(推荐),UltraISO(不太推荐)<br />rufus做好启动盘之后，不需要修改卷标</p><ul><li>UltraIOS启动盘<br />U盘启动电脑进入安装界面</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vmlinuz  initrd&#x3D;initrd.img  inst.stage2&#x3D;hd:LABEL&#x3D;CentOS\x207\x20x86_64 rd.live.check quiet   </span><br><span class="line">#这是按 Tab 键后的默认值；</span><br></pre></td></tr></table></figure><ul><li>rufus 启动<br /><img src="https://static01.imgkr.com/temp/3ed79857352041c88cd07e5e2fa77697.png" alt="启动图片" /></li></ul><p>通常ubuntu桌面和显卡驱动不兼容，导致安装完整之后进入不到桌面<br />解决方法：<br />1:更换桌面管理器<br />2:进入tty 按ctrl+alt+f2</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install lightdm</span><br><span class="line">sudo service lightdm restart</span><br></pre></td></tr></table></figure><p>默认启动多用户启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl set-default multi-user.target</span><br><span class="line">#然后输入reboot命令重启：</span><br></pre></td></tr></table></figure><p>单次启动图形界面:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start graphical.target</span><br><span class="line">switchdesk GNOME&quot;,回车，再输入&quot;startx</span><br></pre></td></tr></table></figure><p>默认启动为图形界面:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl set-default graphical.target</span><br><span class="line">#然后执行reboot命令重启系统即可。</span><br></pre></td></tr></table></figure><h2 id="设置无线上网ubuntu20041是这个目录"><a class="markdownIt-Anchor" href="#设置无线上网ubuntu20041是这个目录"></a> 设置无线上网，Ubuntu20.04.1是这个目录</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;netplan&#x2F;01-network-manager-all.yaml</span><br><span class="line">#添加</span><br><span class="line"> ethernets:</span><br><span class="line">          wlp1s0:   #配置的网卡的名称</span><br><span class="line">              dhcp4: no   #关闭DHCP，如果需要打开DHCP则写yes</span><br><span class="line">              dhcp6: no</span><br><span class="line">              addresses: [192.168.1.10&#x2F;24]   #配置的静态ip地址和掩码</span><br><span class="line">              gateway4: 192.168.1.1       #网关地址</span><br><span class="line">              nameservers:</span><br><span class="line">                   addresses: [192.168.1.1,114.114.114.114]  #DNS服务器地址，多个DNS服务器地址需要用英文逗号分隔开</span><br></pre></td></tr></table></figure><p>使其ip生效</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo netplan apply</span><br></pre></td></tr></table></figure><p>现在查看一下 IP是否生效</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip addr  或者 ifconfig</span><br></pre></td></tr></table></figure><h2 id="frp内网穿透"><a class="markdownIt-Anchor" href="#frp内网穿透"></a> frp内网穿透</h2><p>设备清单：</p><ol><li>一台云主机</li><li>一台家用服务器</li></ol><p>frp 官方地址：<a href="https://github.com/fatedier/frp/">https://github.com/fatedier/frp/</a><br />frp 中文文档：<a href="https://github.com/fatedier/frp/blob/dev/README_zh.md">https://github.com/fatedier/frp/blob/dev/README_zh.md</a></p><p>我这里使用的是第三方，frpMgr极速安装包：<br /><a href="https://github.com/Zo3i/frpMgr">https://github.com/Zo3i/frpMgr</a><br />在云主机里面安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget -O - https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;Zo3i&#x2F;OCS&#x2F;master&#x2F;docker&#x2F;docker-all2.sh | sh</span><br><span class="line">wget -O - https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;Zo3i&#x2F;frpMgr&#x2F;master&#x2F;web&#x2F;src&#x2F;main&#x2F;docker&#x2F;final&#x2F;run.sh | sh</span><br></pre></td></tr></table></figure><p>安装完成登陆：<br />注：代码仅在Centos7,Debian9系统上通过测试</p><p>访问:你的服务器 ip:8999/frp 账号 admin 密码 12345678<br />查看日志命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. docker ps</span><br><span class="line">2. docker logs -f --tail 10 java项目的容器I</span><br></pre></td></tr></table></figure><p>如果需要修改代码,请自行编译 jar包重新部署即可…</p><p><img src="https://static01.imgkr.com/temp/58795ab06b954736ac04f3167e7a6290.jpg" alt="frp后台" /></p><p>详细FRP快捷配置面板<br /><a href="https://github.com/Zo3i/frpMgr/blob/master/README_zh.md">https://github.com/Zo3i/frpMgr/blob/master/README_zh.md</a></p><p>启动，停止，重启frps服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">service frps status</span><br><span class="line">service frps stop</span><br><span class="line">service frps restart</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;起初一直在用云服务器来搭自用服务器，为什么还要用自建一个服务器？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;云服务价格偏高性&lt;/li&gt;
&lt;li&gt;性能达不到要求&lt;/li&gt;
&lt;li&gt;IT人爱折腾，生命不止，学习不止&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;服务器选择&quot;&gt;&lt;a class=&quot;mar
      
    
    </summary>
    
    
      <category term="ubuntu" scheme="https://webwlsong.github.io/tags/ubuntu/"/>
    
      <category term="linux" scheme="https://webwlsong.github.io/tags/linux/"/>
    
      <category term="frp" scheme="https://webwlsong.github.io/tags/frp/"/>
    
      <category term="内网穿透" scheme="https://webwlsong.github.io/tags/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu20.04.1关闭图形界面，使用tty登陆</title>
    <link href="https://webwlsong.github.io/2020/08/30/2020/2020-08/2020-08-30-1/"/>
    <id>https://webwlsong.github.io/2020/08/30/2020/2020-08/2020-08-30-1/</id>
    <published>2020-08-30T03:08:00.000Z</published>
    <updated>2020-09-09T11:54:57.405Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ubuntu-关闭图形界面使用tty登陆"><a class="markdownIt-Anchor" href="#ubuntu-关闭图形界面使用tty登陆"></a> Ubuntu 关闭图形界面，使用tty登陆</h1><p><a href="https://baike.baidu.com/item/TTY">tty</a>是终端设备的统称，TeleTYpe的一个老缩写。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关闭图形界面</span></span><br><span class="line">sudo systemctl set-default multi-user.target</span><br><span class="line">sudo reboot</span><br><span class="line"><span class="comment"># 开启图形界面</span></span><br><span class="line">sudo systemctl set-default graphical.target</span><br><span class="line">sudo reboot</span><br></pre></td></tr></table></figure><p>如果安装使用的是中文，字符显示乱码<br />安装zhcon</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install zhcon</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ubuntu-关闭图形界面使用tty登陆&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#ubuntu-关闭图形界面使用tty登陆&quot;&gt;&lt;/a&gt; Ubuntu 关闭图形界面，使用tty登陆&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://
      
    
    </summary>
    
    
      <category term="ubuntu" scheme="https://webwlsong.github.io/tags/ubuntu/"/>
    
      <category term="linux" scheme="https://webwlsong.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>更换了Hexo博客主题pure使用</title>
    <link href="https://webwlsong.github.io/2020/08/30/2020/2020-08/2020-08-30/"/>
    <id>https://webwlsong.github.io/2020/08/30/2020/2020-08/2020-08-30/</id>
    <published>2020-08-29T16:00:00.000Z</published>
    <updated>2020-09-09T11:54:57.406Z</updated>
    
    <content type="html"><![CDATA[<h1 id="重新换了个清新的blog模版"><a class="markdownIt-Anchor" href="#重新换了个清新的blog模版"></a> 重新换了个清新的blog模版</h1><p><img src="https://webwlsong-1301722012.cos.ap-shanghai.myqcloud.com/mweb/2020/08/30/1598719074737.jpg" alt="1598719074737" /></p><p>看着还不错，后续坚持分享更多有。欢迎大家留言</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;重新换了个清新的blog模版&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#重新换了个清新的blog模版&quot;&gt;&lt;/a&gt; 重新换了个清新的blog模版&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;https://webwlsong-13017220
      
    
    </summary>
    
    
      <category term="hexo" scheme="https://webwlsong.github.io/tags/hexo/"/>
    
      <category term="pure" scheme="https://webwlsong.github.io/tags/pure/"/>
    
  </entry>
  
  <entry>
    <title>基于微服务器 docker下的gitlab安装</title>
    <link href="https://webwlsong.github.io/2020/08/29/2020/2020-08/2020-08-29/"/>
    <id>https://webwlsong.github.io/2020/08/29/2020/2020-08/2020-08-29/</id>
    <published>2020-08-28T16:00:00.000Z</published>
    <updated>2020-09-09T11:54:57.407Z</updated>
    
    <content type="html"><![CDATA[<h1 id="docker-gitlab安装"><a class="markdownIt-Anchor" href="#docker-gitlab安装"></a> docker gitlab安装</h1><p><img src="https://webwlsong-1301722012.cos.ap-shanghai.myqcloud.com/mweb/2020/08/29/oip3.jpeg" alt="OIP" /></p><p>我是在开发机器上面安装</p><h2 id="第一步-在宿主机器上面安装创建gitlab配置目录"><a class="markdownIt-Anchor" href="#第一步-在宿主机器上面安装创建gitlab配置目录"></a> 第一步 在宿主机器上面安装创建gitlab配置目录</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p &#x2F;data&#x2F;gitlab&#x2F;&#123;config,logs,data&#125;</span><br></pre></td></tr></table></figure><h2 id="第二步-创建环境变量指向本地宿主机存储gitlab配置的目录"><a class="markdownIt-Anchor" href="#第二步-创建环境变量指向本地宿主机存储gitlab配置的目录"></a> 第二步 创建环境变量，指向本地宿主机存储gitlab配置的目录：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export GITLAB_HOME&#x3D;&#x2F;data&#x2F;gitlab</span><br></pre></td></tr></table></figure><h2 id="第三步-运行镜像创建容器"><a class="markdownIt-Anchor" href="#第三步-运行镜像创建容器"></a> 第三步 运行镜像，创建容器：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker run --detach \</span><br><span class="line">--hostname 127.0.0.1 \</span><br><span class="line">-p 8443:443 -p 8880:80 -p 8822:22 \</span><br><span class="line">--name gitlab --restart always \</span><br><span class="line">-v $GITLAB_HOME&#x2F;config:&#x2F;etc&#x2F;gitlab \</span><br><span class="line">-v $GITLAB_HOME&#x2F;logs:&#x2F;var&#x2F;log&#x2F;gitlab \</span><br><span class="line">-v $GITLAB_HOME&#x2F;data:&#x2F;vat&#x2F;opt&#x2F;gitlab \</span><br><span class="line">gitlab&#x2F;gitlab-ce:latest</span><br></pre></td></tr></table></figure><p>使用命令lsof -i 端口号 查看端口是否被使用<br />其中由于宿主机的22端口被sshd服务使用，所以改为映射8822端口。80端口被暂用了，改成8880<br />https 已经被占用了。</p><blockquote><p>注意： mac 1024一下的端口号需要 root权限</p></blockquote><hr /><h2 id="第四步-配置gitlab"><a class="markdownIt-Anchor" href="#第四步-配置gitlab"></a> 第四步 配置gitlab</h2><ul><li>配置gitlab<br />容器生成后，根据需要修改gitlab的配置，直接进入宿主机本地映射的config目录，编辑gitlab.rb文件;</li><li>gitlab.rb文件内，主要需要配置的选项如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">## GitLab NGINX</span><br><span class="line">nginx[&#39;listen_port&#39;] &#x3D; 80  # gitlab nginx 端口。默认端口为：80 </span><br><span class="line"> </span><br><span class="line">## GitLab Unicorn</span><br><span class="line">unicorn[&#39;listen&#39;] &#x3D; &#39;localhost&#39;</span><br><span class="line">unicorn[&#39;port&#39;] &#x3D; 8080 #默认是8080端口</span><br><span class="line"> </span><br><span class="line">## GitLab URL 配置http协议所使用的访问地址</span><br><span class="line">external_url GENERATED_EXTERNAL_URL&#39; # clone时显示的地址，gitlab 的域名</span><br><span class="line"> </span><br><span class="line"># 配置ssh协议所使用的访问地址和端口</span><br><span class="line">gitlab_rails[&#39;gitlab_ssh_host&#39;] &#x3D; &#39;song.local&#39;</span><br><span class="line">gitlab_rails[&#39;gitlab_shell_ssh_port&#39;] &#x3D; 8822</span><br></pre></td></tr></table></figure><ul><li>gitlab性能相关的选项如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 超时时间</span><br><span class="line">unicorn[&#39;worker_timeout&#39;] &#x3D; 60        </span><br><span class="line"> </span><br><span class="line">#不能低于2，否则卡死 worker&#x3D;CPU核数+1 </span><br><span class="line">unicorn[&#39;worker_processes&#39;] &#x3D; 2</span><br><span class="line"> </span><br><span class="line"># 减少数据库缓存大小 默认256，可适当改小  </span><br><span class="line">postgresql[&#39;shared_buffers&#39;] &#x3D; &quot;256MB&quot;</span><br><span class="line"> </span><br><span class="line"># 减少数据库并发数</span><br><span class="line">postgresql[&#39;max_worker_processes&#39;] &#x3D; 8</span><br><span class="line"> </span><br><span class="line"># 减少sidekiq并发数</span><br><span class="line">sidekiq[&#39;concurrency&#39;] &#x3D; 10</span><br><span class="line"> </span><br><span class="line"># 减少内存 </span><br><span class="line">unicorn[&#39;worker_memory_limit_min&#39;] &#x3D; &quot;200 * 1 &lt;&lt; 20&quot;</span><br><span class="line">unicorn[&#39;worker_memory_limit_max&#39;] &#x3D; &quot;300 * 1 &lt;&lt; 20&quot;</span><br></pre></td></tr></table></figure><ul><li>配置gitlab的邮箱服务：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">gitlab_rails[&#39;smtp_enable&#39;] &#x3D; true</span><br><span class="line">gitlab_rails[&#39;smtp_address&#39;] &#x3D; &quot;smtp.server&quot;</span><br><span class="line">gitlab_rails[&#39;smtp_port&#39;] &#x3D; 465</span><br><span class="line">gitlab_rails[&#39;smtp_user_name&#39;] &#x3D; &quot;smtp user&quot;</span><br><span class="line">gitlab_rails[&#39;smtp_password&#39;] &#x3D; &quot;smtp password&quot;</span><br><span class="line">gitlab_rails[&#39;smtp_domain&#39;] &#x3D; &quot;example.com&quot;</span><br><span class="line">gitlab_rails[&#39;smtp_authentication&#39;] &#x3D; &quot;login&quot;</span><br><span class="line">gitlab_rails[&#39;smtp_enable_starttls_auto&#39;] &#x3D; true</span><br><span class="line">gitlab_rails[&#39;smtp_openssl_verify_mode&#39;] &#x3D; &#39;peer&#39;</span><br><span class="line"> </span><br><span class="line"># If your SMTP server does not like the default &#39;From: gitlab@localhost&#39; you</span><br><span class="line"># can change the &#39;From&#39; with this setting.</span><br><span class="line">gitlab_rails[&#39;gitlab_email_from&#39;] &#x3D; &#39;gitlab@example.com&#39;</span><br><span class="line">gitlab_rails[&#39;gitlab_email_reply_to&#39;] &#x3D; &#39;noreply@example.com&#39;</span><br></pre></td></tr></table></figure><ul><li>配置完成后，重启gitlab容器即可。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart ####</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;docker-gitlab安装&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#docker-gitlab安装&quot;&gt;&lt;/a&gt; docker gitlab安装&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;https://webwlsong-13017
      
    
    </summary>
    
    
      <category term="docker" scheme="https://webwlsong.github.io/tags/docker/"/>
    
      <category term="gitlab" scheme="https://webwlsong.github.io/tags/gitlab/"/>
    
  </entry>
  
  <entry>
    <title>php 基准测试对比。</title>
    <link href="https://webwlsong.github.io/2017/06/01/2017-06-01/"/>
    <id>https://webwlsong.github.io/2017/06/01/2017-06-01/</id>
    <published>2017-05-31T16:00:00.000Z</published>
    <updated>2020-09-09T11:54:57.402Z</updated>
    
    <content type="html"><![CDATA[<p>php7 相比 Php5.6 提升 2-3 倍。<br />PHP7-JIT 相比 PHP5.6 提升 8 倍。</p><p>如果作为 php 开发者连鸟哥都不认识，起码不是很合格吧。下面是鸟哥做的测试对比。</p><p><img src="php.png" alt="php" /></p><p>下面是鸟哥做的分享。</p><p><a href="https://www.slideshare.net/slideshow/embed_code/key/KMbqLBfzYnMN29">为什么选择 php7？</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;php7 相比 Php5.6 提升 2-3 倍。&lt;br /&gt;
PHP7-JIT 相比 PHP5.6 提升 8 倍。&lt;/p&gt;
&lt;p&gt;如果作为 php 开发者连鸟哥都不认识，起码不是很合格吧。下面是鸟哥做的测试对比。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;php.png&quot; alt=
      
    
    </summary>
    
    
      <category term="php" scheme="https://webwlsong.github.io/tags/php/"/>
    
      <category term="php-jit" scheme="https://webwlsong.github.io/tags/php-jit/"/>
    
  </entry>
  
  <entry>
    <title>operator mono vs fira code</title>
    <link href="https://webwlsong.github.io/2017/05/27/2017-05-27/"/>
    <id>https://webwlsong.github.io/2017/05/27/2017-05-27/</id>
    <published>2017-05-26T16:00:00.000Z</published>
    <updated>2020-09-18T00:57:40.407Z</updated>
    
    <content type="html"><![CDATA[<p>operator mono 和 fira code 两个字体是目前世界上最好的字体。</p><p>1：看看别人的介绍</p><p><a href="https://medium.com/@peterpme/operator-mono-fira-code-the-best-of-both-worlds-191be512fd5e">Operator Mono &amp; Fira Code — The Best of Both Worlds<br /></a></p><p>2：Laravel作者  Eric L. Barnes用的也是这个字体。作者在推特上面发布出了他的配置</p><p><img src="laravel.png" alt="laravel" /></p><p>3：<code>operator mono</code> 是收费字体。fira code是免费字体。<br />如果在mac 安装 <code>fira code</code>  可以使用命令</p><p><code>brew cask install font-fira-code</code><br />最后提供一个 operator mono下载地址<br />链接: <a href="https://pan.baidu.com/s/1nvynUXF">https://pan.baidu.com/s/1nvynUXF</a> 密码: kezv</p><p>4:完成之后效果</p><p><img src="my.png" alt="my" /></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;operator mono 和 fira code 两个字体是目前世界上最好的字体。&lt;/p&gt;
&lt;p&gt;1：看看别人的介绍&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://medium.com/@peterpme/operator-mono-fira-code-the-best
      
    
    </summary>
    
      <category term="mono" scheme="https://webwlsong.github.io/categories/mono/"/>
    
    
      <category term="operator" scheme="https://webwlsong.github.io/tags/operator/"/>
    
      <category term="mono" scheme="https://webwlsong.github.io/tags/mono/"/>
    
      <category term="fira" scheme="https://webwlsong.github.io/tags/fira/"/>
    
      <category term="code" scheme="https://webwlsong.github.io/tags/code/"/>
    
  </entry>
  
  <entry>
    <title>Nginx 限流</title>
    <link href="https://webwlsong.github.io/2017/04/28/2017-04-28-1/"/>
    <id>https://webwlsong.github.io/2017/04/28/2017-04-28-1/</id>
    <published>2017-04-27T16:00:00.000Z</published>
    <updated>2020-09-09T11:54:57.401Z</updated>
    
    <content type="html"><![CDATA[<p>电商平台营销时候，经常会碰到的大流量问题,<br />除了做流量分流处理，可能还要做用户黑白名单、信誉分析，进而根据用户ip信誉权重做相应的流量拦截、限制流量。Nginx自身有的请求限制模块ngx_http_limit_req_module、流量限制模块ngx_stream_limit_conn_module基于令牌桶算法，可以方便的控制令牌速率，自定义调节限流，实现基本的限流控制。</p><p>对于提供下载的网站，肯定是要进行流量控制的，例如软件下载站、视频服务等。它也可以减少一些爬虫程序或者DDOS的攻击。</p><p>对这两个模块的介绍的文章也不少，这里转载一篇hopestar的文章: nginx限制IP连接数的范例参考， 因为他介绍的很简洁。</p><blockquote><p>如何Nginx限制同一个ip的连接数，限制并发数目:</p></blockquote><h2 id="1-限流"><a class="markdownIt-Anchor" href="#1-限流"></a> 1. 限流</h2><ul><li>添加limit_zone和limit_req_zone;<br />这个变量只能在http使用 :</li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vi /export/servers/nginx/conf/nginx.conf </span><br><span class="line">limit_zone one  <span class="variable">$binary_remote_addr</span>  <span class="number">20</span>m;</span><br><span class="line">limit_req_zone  <span class="variable">$binary_remote_addr</span>  zone=req_one:<span class="number">20</span>m rate=<span class="number">12</span><span class="built_in">r</span>/s; </span><br><span class="line">    </span><br></pre></td></tr></table></figure><ul><li>添加limit_conn 和limit_req</li></ul><p>这个变量可以在<code>http</code>, <code>server</code>, <code>location</code>使用 我是限制nginx上的所有服务，所以添加到http里面 （如果你需要限制部分服务，可在nginx/conf/domains里面选择相应的server或者location添加上便可）</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vi /export/servers/nginx/conf/nginx.conf </span><br><span class="line">limit_zone one <span class="variable">$binary_remote_addr</span> <span class="number">20</span>m;</span><br><span class="line">limit_req_zone <span class="variable">$binary_remote_addr</span> zone=req_one:<span class="number">20</span>m rate=<span class="number">12</span><span class="built_in">r</span>/s;</span><br><span class="line">limit_conn one <span class="number">10</span>;</span><br><span class="line">limit_req zone=req_one burst=<span class="number">120</span>;</span><br></pre></td></tr></table></figure><p>参数详解(数值按具体需要和服务器承载能力设置,):</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">limit_zone，是针对每个变量(这里指IP，即<span class="variable">$binary_remote_addr</span>)定义一个存储session状态的容器。  </span><br><span class="line">            这个示例中定义了一个<span class="number">20</span>m的容器，按照<span class="number">32</span>bytes/session，  </span><br><span class="line">            可以处理<span class="number">640000</span>个session。 </span><br><span class="line">limit_req_zone 与limit_zone类似。rate是请求频率. 每秒允许<span class="number">12</span>个请求。</span><br><span class="line">limit_conn  one <span class="number">10</span> : 表示一个IP能发起<span class="number">10</span>个并发连接数</span><br><span class="line">limit_req: 与limit_req_zone对应。burst表示缓存住的请求数。</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">http</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">limit_zone</span> one  $binary_remote_addr  <span class="number">20m</span>;</span><br><span class="line">    <span class="attribute">limit_req_zone</span>  $binary_remote_addr  zone=req_one:<span class="number">20m</span> rate=12r/s;</span><br><span class="line">    <span class="attribute">limit_conn</span>   one  <span class="number">10</span>;</span><br><span class="line">    <span class="attribute">limit_req</span>   zone=req_one burst=<span class="number">120</span>;</span><br><span class="line">    <span class="section">server</span>  &#123;</span><br><span class="line">        <span class="attribute">listen</span>          <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span>     status.xxx.com ;</span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">                 <span class="attribute">stub_status</span>            <span class="literal">on</span>;</span><br><span class="line">                 <span class="attribute">access_log</span>             <span class="literal">off</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启nginx</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/export/servers/nginx/sbin/nginx -s reload</span><br></pre></td></tr></table></figure><h2 id="2-nginx白名单设置"><a class="markdownIt-Anchor" href="#2-nginx白名单设置"></a> 2. nginx白名单设置</h2><p>以上配置会对所有的ip都进行限制，有些时候我们不希望对搜索引擎的蜘蛛或者某些自己的代理机过来的请求进行限制， 对于特定的白名单ip我们可以借助geo指令实现。</p><p>先在nginx的请求日志进行统计，查看那个ip的访问量比较大， 运行:</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cat</span> access.<span class="built_in">log</span> | <span class="keyword">grep</span> <span class="string">&quot;03/Jun&quot;</span> |awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span>|<span class="keyword">sort</span> |uniq -<span class="keyword">c</span>|<span class="keyword">sort</span> -nrk <span class="number">1</span>|head -n <span class="number">10</span></span><br><span class="line">#列出访问日志里面在<span class="number">6</span>月<span class="number">3</span>号这天前<span class="number">10</span>个访问量最大的ip.</span><br></pre></td></tr></table></figure><p>接下来就可以对这些IP进行分析了。看哪些需要进行白名单设置。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">http</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">geo</span>  $limited  &#123; <span class="comment"># the variable created is $limited</span></span><br><span class="line">        <span class="attribute">default</span>          <span class="number">1</span>;</span><br><span class="line">        127.0.0.1/32     0;</span><br><span class="line">        10.12.212.63     0;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">map</span> $limited $limit &#123;</span><br><span class="line">        1 $binary_remote_addr;</span><br><span class="line">        0 &quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">limit_zone</span> one  $binary_remote_addr  <span class="number">20m</span>;</span><br><span class="line">    <span class="attribute">limit_req_zone</span>  $limit  zone=req_one:<span class="number">20m</span> rate=20r/s;</span><br><span class="line">    <span class="attribute">limit_conn</span>   one  <span class="number">10</span>;</span><br><span class="line">    <span class="attribute">limit_req</span>   zone=req_one burst=<span class="number">120</span>;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><p>上面两个需要用到map和geo模块，这是nginx自带的模块，有的运维喜欢把他们关闭，自己<code>./sbin/nginx -V</code> 留意一下。把配置的<code>--whithout-XXX-module</code>去掉重新编译一下就可以了。 上面这段配置的意思是：</p><p>geo指令定义了一个白名单<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>i</mi><mi>m</mi><mi>i</mi><mi>t</mi><mi>e</mi><mi>d</mi><mi mathvariant="normal">变</mi><mi mathvariant="normal">量</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">默</mi><mi mathvariant="normal">认</mi><mi mathvariant="normal">值</mi><mi mathvariant="normal">为</mi><mn>1</mn><mi mathvariant="normal">，</mi><mi mathvariant="normal">如</mi><mi mathvariant="normal">果</mi><mi mathvariant="normal">客</mi><mi mathvariant="normal">户</mi><mi mathvariant="normal">端</mi><mi>i</mi><mi>p</mi><mi mathvariant="normal">在</mi><mi mathvariant="normal">上</mi><mi mathvariant="normal">面</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">范</mi><mi mathvariant="normal">围</mi><mi mathvariant="normal">内</mi><mi mathvariant="normal">，</mi></mrow><annotation encoding="application/x-tex">limited变量，默认值为1，如果客户端ip在上面的范围内，</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">i</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">d</span><span class="mord cjk_fallback">变</span><span class="mord cjk_fallback">量</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">默</span><span class="mord cjk_fallback">认</span><span class="mord cjk_fallback">值</span><span class="mord cjk_fallback">为</span><span class="mord">1</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">如</span><span class="mord cjk_fallback">果</span><span class="mord cjk_fallback">客</span><span class="mord cjk_fallback">户</span><span class="mord cjk_fallback">端</span><span class="mord mathdefault">i</span><span class="mord mathdefault">p</span><span class="mord cjk_fallback">在</span><span class="mord cjk_fallback">上</span><span class="mord cjk_fallback">面</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">范</span><span class="mord cjk_fallback">围</span><span class="mord cjk_fallback">内</span><span class="mord cjk_fallback">，</span></span></span></span>limited的值为0<br />使用map指令映射搜索引擎客户端的ip为空串，如果不是搜索引擎就显示本身真实的ip，这样搜索引擎ip就不能存到limit_req_zone内存session中，所以不会限制搜索引擎的ip访问</p><h2 id="3-获取客户端的真实ip"><a class="markdownIt-Anchor" href="#3-获取客户端的真实ip"></a> 3. 获取客户端的真实IP</h2><p>顺带一提，为了获取客户端的真实IP。该模块需要安装read_ip模块，运维应该默认有安装。没有的话也可自行安装： 配置方式相当简单，重新编译 Nginx 加上 --with-http_realip_module 参数，如：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./configure -<span class="literal">-prefix</span>=/opt/nginx -<span class="literal">-with</span><span class="literal">-http_stub_status_module</span>  -<span class="literal">-with</span><span class="literal">-pcre</span>=../pcre<span class="literal">-6</span>.<span class="number">6</span> -<span class="literal">-with</span><span class="literal">-http_realip_module</span></span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>在server中增加:</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">set_real_ip_from</span>   <span class="number">192.168.1.0</span>/<span class="number">24</span>;</span><br><span class="line"><span class="attribute">set_real_ip_from</span>   <span class="number">192.168.2.1</span>;</span><br><span class="line"><span class="attribute">real_ip_header</span>     [X-Real-IP|X-Forwarded-For];</span><br></pre></td></tr></table></figure><p>需要说明的地方就是设置IP源的时候可以设置单个IP，也可以设置IP段，另外是使用X-Real-IP还是X-Forwarded-For，取决于前面的服务器有哪个头。</p><p>set_real_ip_from 设置的IP端可以让运维查看日志，看下你的请求是来自哪些ip段。</p><p>重新加载一下服务，差不多就OK了。</p><p>再查看日志的话，应该可以看到客户端的真实IP了。</p><p>注意：如果未安装该模块的话你的获取到的IP端可能是来自前端代理（如squid）的IP，结果就是多个用户被当成单个用户对待，导致应用不能响应。</p><p>再PS一下： 自测: 有条件的自己可以用ab或者webben自测一下。</p><p>未安装前压测的话，因为有大量请求，所以access.log会有大量日志，而error.log日志没有变化。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ webbench  <span class="literal">-c</span> <span class="number">30</span> <span class="literal">-t</span> <span class="number">30</span> http://xxx.com</span><br><span class="line">Webbench - Simple Web Benchmark <span class="number">1.5</span></span><br><span class="line">Copyright (c) Radim Kolar <span class="number">1997</span><span class="literal">-2004</span>, GPL Open Source Software.</span><br><span class="line">Benchmarking: GET http://xxx.com  </span><br><span class="line"><span class="number">30</span> clients, running <span class="number">30</span> sec.</span><br><span class="line">Speed=<span class="number">193468</span> pages/min, <span class="number">1254317</span> bytes/sec.</span><br><span class="line">Requests: <span class="number">96734</span> susceed, <span class="number">0</span> failed.</span><br></pre></td></tr></table></figure><p>安装后会发现很多超出的请求会返回503,所以access.log日志变化不快，error.log有大量记录,提示limit_reque缓住了多少请求。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ webbench  <span class="literal">-c</span> <span class="number">30</span> <span class="literal">-t</span> <span class="number">30</span> http://xxxx.com</span><br><span class="line">Webbench - Simple Web Benchmark <span class="number">1.5</span></span><br><span class="line">Copyright (c) Radim Kolar <span class="number">1997</span><span class="literal">-2004</span>, GPL Open Source Software.</span><br><span class="line">Benchmarking: GET http://xxx.com  </span><br><span class="line"><span class="number">30</span> clients, running <span class="number">30</span> sec.</span><br><span class="line">Speed=<span class="number">120</span> pages/min, <span class="number">778</span> bytes/sec.</span><br><span class="line">Requests: <span class="number">60</span> susceed, <span class="number">0</span> failed.</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;电商平台营销时候，经常会碰到的大流量问题,&lt;br /&gt;
除了做流量分流处理，可能还要做用户黑白名单、信誉分析，进而根据用户ip信誉权重做相应的流量拦截、限制流量。Nginx自身有的请求限制模块ngx_http_limit_req_module、流量限制模块ngx_strea
      
    
    </summary>
    
    
      <category term="nginx" scheme="https://webwlsong.github.io/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>Nginx 负载均衡策略</title>
    <link href="https://webwlsong.github.io/2017/04/28/2017-04-28/"/>
    <id>https://webwlsong.github.io/2017/04/28/2017-04-28/</id>
    <published>2017-04-27T16:00:00.000Z</published>
    <updated>2020-09-18T00:57:40.414Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>轮询（默认）每个web请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Upstream nginxDemo&#123;</span><br><span class="line">    server 127.0.0.1:8001;</span><br><span class="line">    server 127.0.0.1:8002;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>最少链接web请求会被转发到连接数最少的服务器上。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Upstream nginxDemo&#123;</span><br><span class="line">    least_conn;</span><br><span class="line">    server 127.0.0.1:8001;</span><br><span class="line">    server 127.0.0.1:8002;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>weight 权重指定轮询几率，weight和访问比率成正比，用 于后端服务器性能不均的情况，weight默认是1。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#服务器A和服务器B的访问比例：2-1；比如有3个请求，前两个会访问A，第三个会访问B，其他的归着和轮询一样。</span><br><span class="line"></span><br><span class="line">Upstream nginxDemo&#123;</span><br><span class="line">    least_conn;</span><br><span class="line">    server 127.0.0.1:8001;</span><br><span class="line">    server 127.0.0.1:8002;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>ip_hash每个请求按访问ip的hash值分配，这样同一客户端连续的Web请求都会被分发到同一服务器进行处理，可以解决session的问题。当后台服务器宕机时，会自动跳转到其它服务器。基于weight的负载均衡和基于ip_hash的负载均衡可以组合在一起使用。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ip_hash;</span><br><span class="line">Upstream nginxDemo&#123;</span><br><span class="line">    server 127.0.0.1:8001 weight&#x3D;2; #服务器A</span><br><span class="line">    server 127.0.0.1:8002; #服务器B</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>url_hash（第三方）url_hash是nginx的第三方模块，nginx本身不支持，需要打补丁。nginx按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存服务器、文件服务器、静态服务器时比较有效。缺点是当后端服务器宕机的时候，url_hash不会自动跳转的其他缓存服务器，而是返回给用户一个503错误。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Upstream nginxDemo&#123;</span><br><span class="line">    server 127.0.0.1:8001 weight&#x3D;2; #服务器A</span><br><span class="line">    server 127.0.0.1:8002; #服务器B</span><br><span class="line">    hash  $request_url;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>fair（第三方）按后端服务器的响应时间来分配请求，响应时间短的优先分配。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Upstream nginxDemo&#123;</span><br><span class="line">    server 127.0.0.1:8001 weight&#x3D;2; #服务器A</span><br><span class="line">    server 127.0.0.1:8002; #服务器B</span><br><span class="line">    hair;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;
&lt;p&gt;轮询（默认）每个web请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。&lt;/p&gt;
 &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;sp
      
    
    </summary>
    
      <category term="nginx" scheme="https://webwlsong.github.io/categories/nginx/"/>
    
    
      <category term="nginx" scheme="https://webwlsong.github.io/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>IntelliJ Idea 2017 免费激活方法</title>
    <link href="https://webwlsong.github.io/2017/04/27/2017-04-27/"/>
    <id>https://webwlsong.github.io/2017/04/27/2017-04-27/</id>
    <published>2017-04-26T16:00:00.000Z</published>
    <updated>2020-09-09T11:54:57.404Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>第一种方法：<br />到网站 <a href="http://idea.lanyus.com/">http://idea.lanyus.com/</a> 获取注册码。</p></li><li><p>第二种方法：<br />首先：<code>0.0.0.0 account.jetbrains.com</code> 添加到<code>hosts</code><br />填入下面的license server:</p></li></ol><p><a href="http://intellij.mandroid.cn/">http://intellij.mandroid.cn/</a><br />　　<a href="http://idea.imsxm.com/">http://idea.imsxm.com/</a><br />　　<a href="http://idea.iteblog.com/key.php">http://idea.iteblog.com/key.php</a></p><p>以上方法验证均可以</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;
&lt;p&gt;第一种方法：&lt;br /&gt;
到网站 &lt;a href=&quot;http://idea.lanyus.com/&quot;&gt;http://idea.lanyus.com/&lt;/a&gt; 获取注册码。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第二种方法：&lt;br /&gt;
首先：&lt;code&gt;0
      
    
    </summary>
    
    
      <category term="phpstrom" scheme="https://webwlsong.github.io/tags/phpstrom/"/>
    
      <category term="jetbrains" scheme="https://webwlsong.github.io/tags/jetbrains/"/>
    
  </entry>
  
  <entry>
    <title>php nodejs nginx 进程模型对比</title>
    <link href="https://webwlsong.github.io/2017/04/25/2017-04-25/"/>
    <id>https://webwlsong.github.io/2017/04/25/2017-04-25/</id>
    <published>2017-04-24T16:00:00.000Z</published>
    <updated>2020-09-09T11:54:57.403Z</updated>
    
    <content type="html"><![CDATA[<h2 id="php-进程模型"><a class="markdownIt-Anchor" href="#php-进程模型"></a> PHP 进程模型</h2><p>PHP-FPM 是 PHP 针对 FastCGI 协议的具体实现，也是 PHP 在多种服务器端应用编程端口（SAPI：cgi、fast-cgi、cli、isapi、apache）里使用最普遍、性能最佳的一款进程管理器。</p><p>PHP-FPM 这种模型是非常典型的多进程同步模型，意味着一个请求对应一个进程线程，并且 IO 是同步阻塞的。所以尽管 PHP-FPM 维护着独立的 CGI 进程池、系统也可以很轻松的管理进程的生命周期，</p><p>受制于服务器的硬件设施，PHP-FPM 需要指定合理的 php-fpm.conf 配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pm.max_children # 子进程最大数</span><br><span class="line">pm.start_servers # 启动时的子进程数</span><br><span class="line">pm.min_spare_servers # 最小空闲进程数，空闲进程不够时自动补充</span><br><span class="line">pm.max_spare_servers # 最大空闲进程数，空闲进程超过时自动清理</span><br><span class="line">pm.max_requests &#x3D; 1000 # 子进程请求数阈值，超过后自动回收</span><br></pre></td></tr></table></figure><p>PHP 进程本身并不存在内存泄露的问题，每个进程完成请求处理后会回收内存，但是并不会释放给操作系统，这就导致大量内存被 PHP-FPM 占用而无法释放，请求量升高时性能骤降。</p><p>所以 PHP-FPM 需要控制单个子进程请求次数的阈值。很多人会误以为 max_requests 控制了进程的并发连接数，实际上 PHP-FPM 模式下的进程是单一线程的，请求无法并发。这个参数的真正意义是提供请求计数器的功能，超过阈值数目后自动回收，缓解内存压力。</p><h2 id="nginx进程模型"><a class="markdownIt-Anchor" href="#nginx进程模型"></a> nginx进程模型</h2><p>Nginx 是非阻塞IO &amp; IO复用模型，通过操作系统提供的类似 epoll 的功能，可以在一个线程里处理多个客户端的请求。<br />Nginx 的进程就是线程，即每个进程里只有一个线程，但这一个线程可以服务多个客户端。</p><p>nginx在启动后，会有一个master进程和多个worker进程。master进程主要用来管理worker进程，包含：接收来自外界的信号，向各worker进程发送信号，监控worker进程的运行状态，当worker进程退出后(异常情况下)，会自动重新启动新的worker进程。而基本的网络事件，则是放在worker进程中来处理了。多个worker进程之间是对等的，他们同等竞争来自客户端的请求，各进程互相之间是独立的。一个请求，只可能在一个worker进程中处理，一个worker进程，不可能处理其它进程的请求。worker进程的个数是可以设置的，一般我们会设置与机器cpu核数一致，这里面的原因与nginx的进程模型以及事件处理模型是分不开的</p><p>因此才有了异步非阻塞的事件处理机制。具体到系统调用就是像select/poll/epoll/kqueue这样的系统调用。他们提供了一种机制，让你可以同时监控多个事件，调用他们是阻塞的，但可以设置超时时间，在超时时间之内，如果有事件准备好了，就返回。这种机制解决了我们上面两个问题。</p><p>以epoll为例：当事件没有准备好时，就放入epoll里面。如果有事件准备好了，那么就去处理；如果事件返回的是EAGAIN，那么继续将其放入epoll里面。从而，只要有事件准备好了，我们就去处理她，只有当所有时间都没有准备好时，才在epoll里面等着。这样，我们就可以并发处理大量的并发了，当然，这里的并发请求，是指未处理完的请求，线程只有一个，所以同时能处理的请求当然只有一个了，只是在请求间进行不断地切换而已，切换也是因为异步事件未准备好，而主动让出的。这里的切换是没有任何代价，你可以理解为循环处理多个准备好的事件，事实上就是这样的。</p><h2 id="nodejs-进程模型"><a class="markdownIt-Anchor" href="#nodejs-进程模型"></a> nodejs 进程模型</h2><p>我们都知道nodejs最大的特点就是单进程、无阻塞运行，并且是异步事件驱动的。Nodejs的这些特性能够很好的解决一些问题，例如在服务器开发中，并发的请求处理是个大问题，阻塞式的函数会导致资源浪费和时间延迟。通过事件注册、异步函数，开发人员可以提高资源的利用率，性能也会改善。既然Node.js采用单进程、单线程模式，那么在如今多核硬件流行的环境中，单核性能出色的Nodejs如何利用多核CPU呢？创始人Ryan Dahl建议，运行多个Nodejs进程，利用某些通信机制来协调各项任务。目前，已经有不少第三方的Node.js多进程支持模块发布，而NodeJS 0.6.x 以上的版本提供了一个cluster模块 ,允许创建“共享同一个socket”的一组进程,用来分担负载压力。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;php-进程模型&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#php-进程模型&quot;&gt;&lt;/a&gt; PHP 进程模型&lt;/h2&gt;
&lt;p&gt;PHP-FPM 是 PHP 针对 FastCGI 协议的具体实现，也是 PHP 在多种服务器端应用编程端口（
      
    
    </summary>
    
    
      <category term="php" scheme="https://webwlsong.github.io/tags/php/"/>
    
      <category term="nodejs" scheme="https://webwlsong.github.io/tags/nodejs/"/>
    
      <category term="nginx" scheme="https://webwlsong.github.io/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>测试一下 qq和淘宝网页的测试</title>
    <link href="https://webwlsong.github.io/2017/04/17/2017-04-17/"/>
    <id>https://webwlsong.github.io/2017/04/17/2017-04-17/</id>
    <published>2017-04-16T16:00:00.000Z</published>
    <updated>2020-09-09T11:54:57.427Z</updated>
    
    <content type="html"><![CDATA[<p>为什么做这个测试？最近有人你们的app接口能支持多大的并发，能支持多少的用户。<br />答： 这个本身就是个伪命题，没有场景话，很难回答。就好像，你们怎么做优化，这本身也是个伪命题。<br />如果要回答，网上google一下，有很多，问题在于你们的场景能用的到吗？如果要谈，这个很大的话题。<br />每个话题展开都能谈很久。</p><h2 id="延迟分析"><a class="markdownIt-Anchor" href="#延迟分析"></a> 延迟分析</h2><p>同城机房网络(0.5ms~2ms) max(1000qps)<br />jvm-gc(50ms左右) max(20qps)<br />如果是异地机房，例如北京到上海机房，一次网络往返可能就13～20毫秒延迟。max(50qps)</p><p>![测试图](2017-04-17 at 14.04.47.gif)<br />（测试图）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;为什么做这个测试？最近有人你们的app接口能支持多大的并发，能支持多少的用户。&lt;br /&gt;
答： 这个本身就是个伪命题，没有场景话，很难回答。就好像，你们怎么做优化，这本身也是个伪命题。&lt;br /&gt;
如果要回答，网上google一下，有很多，问题在于你们的场景能用的到吗？如
      
    
    </summary>
    
    
      <category term="性能测试" scheme="https://webwlsong.github.io/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>docker ubuntu ping source 不能使用</title>
    <link href="https://webwlsong.github.io/2016/11/28/2016-11-28/"/>
    <id>https://webwlsong.github.io/2016/11/28/2016-11-28/</id>
    <published>2016-11-27T16:00:00.000Z</published>
    <updated>2020-09-09T11:54:57.399Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用docker-拉取ubunut-镜像"><a class="markdownIt-Anchor" href="#使用docker-拉取ubunut-镜像"></a> 使用docker 拉取ubunut 镜像</h1><p>我本地使用的ubuntu 镜像版本如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sh-4.3# cat &#x2F;etc&#x2F;issue</span><br><span class="line">Ubuntu 16.04.1 LTS \n \l</span><br><span class="line"></span><br><span class="line">sh-4.3#</span><br></pre></td></tr></table></figure><h2 id="拉取ubuntu进行你会发现有的镜像ping都不通"><a class="markdownIt-Anchor" href="#拉取ubuntu进行你会发现有的镜像ping都不通"></a> 拉取ubuntu进行，你会发现有的镜像Ping都不通</h2><p>解决方法： apt-get update 更新源</p><h2 id="source-和-ubunut的代码补全也不能使用"><a class="markdownIt-Anchor" href="#source-和-ubunut的代码补全也不能使用"></a> source 和 ubunut的代码补全也不能使用</h2><p>shell脚本中source  时提示 source: not found</p><p>Debian和Ubuntu中，/bin/sh默认已经指向dash，这是一个不同于bash的shell，它主要是为了执行脚本而出现，而不是交互，它速度更快，但功能相比bash要少很多，语法严格遵守POSIX标准</p><p>dash不是为交互而生的，所以我们在使用过程中还是习惯的修改成bash</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ls -l &#x2F;bin&#x2F;sh  </span><br><span class="line">显示 &#x2F;bin&#x2F;sh  -&gt;dash </span><br><span class="line">显示使用的是dash </span><br></pre></td></tr></table></figure><p>修改默认的shell</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg-reconfigure dash</span><br><span class="line"></span><br><span class="line">再次检查一下， ls &#x2F;bin&#x2F;sh -al 发现软链接指向&#x2F;bin&#x2F;bash</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="恢复ubuntu-bash下的自动补全"><a class="markdownIt-Anchor" href="#恢复ubuntu-bash下的自动补全"></a> 恢复ubuntu bash下的自动补全</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">1. 确认&#x2F;etc&#x2F;bash_completion是否存在，如果没有就安装一个：</span><br><span class="line">2. apt-get install bash-completion</span><br><span class="line">在用户的shell中运行：</span><br><span class="line">3. source &#x2F;etc&#x2F;bash_completion</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="添加新的用户-ubuntn下面"><a class="markdownIt-Anchor" href="#添加新的用户-ubuntn下面"></a> 添加新的用户 ubuntn下面</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">useradd  -m username  &#x2F;&#x2F;ubuntu 自动创建用户目录</span><br><span class="line">passwd username  &#x2F;&#x2F;创建密码</span><br><span class="line">usermod -a -G sudo username &#x2F;&#x2F;用户拥有权限</span><br><span class="line"></span><br><span class="line">ubuntu 默认的是dash shell</span><br><span class="line"></span><br><span class="line">修改成 bash</span><br><span class="line">vi &#x2F;etc&#x2F;passwd </span><br><span class="line">1.username:x:1000:1000::&#x2F;home&#x2F;username</span><br><span class="line">修成成如下：</span><br><span class="line">2. username:x:1000:1000::&#x2F;home&#x2F;username:&#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;使用docker-拉取ubunut-镜像&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#使用docker-拉取ubunut-镜像&quot;&gt;&lt;/a&gt; 使用docker 拉取ubunut 镜像&lt;/h1&gt;
&lt;p&gt;我本地使用的ubuntu 镜像版本如
      
    
    </summary>
    
    
      <category term="ubuntu" scheme="https://webwlsong.github.io/tags/ubuntu/"/>
    
      <category term="docker" scheme="https://webwlsong.github.io/tags/docker/"/>
    
  </entry>
  
</feed>
